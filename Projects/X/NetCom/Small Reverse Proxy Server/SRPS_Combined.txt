; ==================================================================================================
; Title:      NetCom.inc
; Author:     G. Friedrich
; Version:    C.1.0
; Purpose:    ObjAsm object cluster. Support of NetCom objects.
; Links:      - http://www.codeproject.com/KB/IP/jbsocketserver3.aspx
;             - http://msdn.microsoft.com/en-us/library/ms741394(VS.85).aspx
;             - http://msdn.microsoft.com/en-us/library/aa938522.aspx
;             - http://msdn.microsoft.com/en-us/library/aa364510(VS.85).aspx - HTTP API reference
;             - http://msdn.microsoft.com/en-us/library/ms740673(VS.85).aspx   Socks2
;             - http://msdn.microsoft.com/en-us/library/ms738547.aspx          Graceful shutdown
;             - http://msdn.microsoft.com/en-us/library/ms740668(VS.85).aspx   WSA Error codes
;             - http://www.chebucto.ns.ca/~rakerman/port-table.html            Port table
;             - http://www.iana.org/assignments/port-numbers                   IANA official port nbrs
;             - http://support.microsoft.com/kb/196271/EN-US/                  Port number restriction
;             - http://www.microsoft.com/technet/itsolutions/network/deploy/depovg/tcpip2k.asp Implem.
;             - http://rdweb.cns.vt.edu/public/notes/win2k-tcpip.htm           Registry settings
;             - http://msdn.microsoft.com/de-ch/magazine/cc302334(en-us).aspx
;             - http://support.microsoft.com/kb/192800/en                      Important reading IOCP
;             - http://support.microsoft.com/kb/181611/en                      SO_SNDBUF = 0
;             - http://msdn.microsoft.com/en-us/library/ms810434.aspx          IOCP internal descrip.
;             - https://support.microsoft.com/en-nz/help/929851/the-default-dynamic-port-range-for-
;                       tcp-ip-has-changed-in-windows-vista
;
; Notes:      include the following objects in the main asm file using
;               LoadObjects StopWatch
;               LoadObjects NetComAddrCollection
;             and all necessary ancestors not previously included.
;
;             Our typical TCP streaming connections use the 'session global' copy of the
;             RemoteAddr field, stored in NetComConnection. The newly-supported SOCK_SEQPACKET
;             will also use that. But the SOCK_DGRAM, SOCK_RDM and SOCK_RAW will use the
;             'session local' copy of the RemoteAddr field, stored in IOSockJob.
;             This is because these socket types typically communicate with multiple remote hosts,
;             so we are tagging messages with host ids. This allows us to associate a message with
;             an individual remote host.
;
;             Configure your firewalls according to the "dynamic client port range" (49152 - 65535).
;
;             ServiceNames: look at %WINDIR%\system32\drivers\etc\services
;
;             Version C.1.0, October 2017
;               - First release.
; ==================================================================================================



;                                   Object relationship
;                                   -------------------
;
;
;                         -------------------
;          ------------->|    Application    |<----------
;         |              |-------------------|           |
;         |              |                   |           |
;         |              |                   |           |
;         |              |                   |           |
;         |               -------------------            |
;         |                                              |
;         |                                              |
;         |          Server/Client                       |              Functionality
;         |       -------------------                    |            -------------------
;         |   -->|   NetComEngine    |<----              |   ------->|  NetComProtocol   |
;         |  |   |-------------------|     |             |  |        |-------------------|
;          --|---| pOwner            |     |              --|--------| pOwner            |
;            |   |                   |     |                |        |                   |
;            |   |                   |     |                |        |                   |
;            |    -------------------      |                |         -------------------
;            |                             |                |
;            |                              ----------------|----
;            |                                              |    |
;            |           --------------------               |    |    -------------------
;            |       -->|NetComConnectionPool|        ------|------->|NetComIOSockJobPool|- - -
;            |      |   |--------------------|       |      |    |   |-------------------|     |
;             ------|---| pOwner             |       |      |     ---| pOwner            |
;                   |   |     pIOSockJobPool |-------       |        | dBufferSize       |     |
;                   |   |                    |              |        |                   |
;                   |    --------------------               |         -------------------      |
;                   |                                       |
;                   |                                       |                                  |
;                   |                                       |
;                   |           -------------------         |        -------------------       |
;                   |          | NetComConnection  |< - - - | - - - |  NetComIOSockJob  |< - -
;                   |          |-------------------||       |       |-------------------||
;                    ----------| pOwner            |||      |       |                   |||
;                              |         pProtocol |||------        |                   ||||
;                              |                   |||              |                   |||||
;                               ------------------- ||               ------------------- |||||
;                                ------------------- |                ------------------- ||||
;                                 -------------------                  ------------------- |||
;                                                                       --------------------||
;                                                                        ------------------- |
;                                                                         -------------------
;
;
; ==================================================================================================


SO_CONNECT_TIME             equ   0700Ch
;SO_EXCLUSIVEADDRUSE

;IO socket operations
OPERATION_SOCK_ACCEPT       equ   1h
OPERATION_SOCK_CONNECT      equ   2h
OPERATION_SOCK_RECV         equ   3h
OPERATION_SOCK_SEND         equ   4h

;IO Flag
IOF_JOB_COMPLETED           equ   BIT00     ;Completed
IOF_JOB_LINKED              equ   BIT01     ;Linked to the receive chain

ERROR_BAD_PROTOCOL          equ   -10
ERROR_USER_QUIT             equ   -12

;Protocol commands
PROT_CMD_ACCEPT_CONNECTION  equ   1
PROT_CMD_REJECT_CONNECTION  equ   2
PROT_CMD_DISCONNECT         equ   3         ;Connection teardown
PROT_CMD_CLOSE              equ   4         ;Connection cut
PROT_CMD_CONTINUE           equ   5         ;Continue actual operation
PROT_CMD_DELETE_IOJOBS      equ   6
PROT_CMD_DESTROY            equ   7         ;Destroy connection object
PROT_CMD_STOP               equ   8         ;Stop engine - fatal error

;NetCom Connection flags
NCC_SHUTDOWN_RX_REMOTE      equ   BIT00
NCC_SHUTDOWN_TX_REMOTE      equ   BIT01
NCC_SHUTDOWN_RX_LOCAL       equ   BIT02
NCC_SHUTDOWN_TX_LOCAL       equ   BIT03
;Lifecycle control
NCC_DESTROY_QUEUED          equ   BIT04     ;Marked to terminate the connection object
NCC_DESTROYED               equ   BIT05     ;Done - socket Closed (abortive disconnection) and free
NCC_CLOSED                  equ   BIT06
;Backpressure control
NCC_RX_PAUSED               equ   BIT07
NCC_TX_PAUSED               equ   BIT08

NCC_DISCONNECTED_LOCAL      equ   NCC_SHUTDOWN_RX_LOCAL  or NCC_SHUTDOWN_TX_LOCAL
NCC_DISCONNECTED_REMOTE     equ   NCC_SHUTDOWN_RX_REMOTE or NCC_SHUTDOWN_TX_REMOTE
NCC_DISCONNECTED_SEND       equ   NCC_SHUTDOWN_RX_REMOTE or NCC_SHUTDOWN_TX_LOCAL
NCC_DISCONNECTED_RECEIVE    equ   NCC_SHUTDOWN_RX_LOCAL  or NCC_SHUTDOWN_TX_REMOTE

;NetCom Error states
NCE_ACCEPT                  equ   BIT27     ;Error happend while accepting
NCE_CONNECT                 equ   BIT28     ;Error happend while connecting
NCE_SEND                    equ   BIT29     ;Error happend while sending
NCE_RECEIVE                 equ   BIT30     ;Error happend while receiving
NCE_UNKNOWN                 equ   BIT31     ;Error happend during an unknown operation

;Error codes
ERROR_BASE = 111111110
AddErrMsg NCE_WINSOCK_INIT_FAILED,          "NetComEngine failed initializing WinSock library"
AddErrMsg NCE_IOCP_INIT_ERROR,              "NetComEngine failed to create an IOCP"
AddErrMsg NCE_THREAD_CREATION_FAILED,       "NetComEngine failed creating a thread"
AddErrMsg NCE_SOCKET_CREATION_FAILED,       "NetComEngine failed to create a socket"
AddErrMsg NCE_LISTENER_BIND_ERROR,          "NetComEngine failed to bind listener socket"
AddErrMsg NCE_LISTENER_DOESNT_LISTEN,       "Listening socked failed to listen"
AddErrMsg NCE_LISTENER_IOCP_BIND_FAILED,    "Failed to bind the listener socket to the IOCP"

AddErrMsg NCCP_OUT_OF_MEMORY,               "Out of memory in NetComConnectionPool"
AddErrMsg NCJP_OUT_OF_MEMORY,               "Out of memory in NetComIOSockJobPool"

AddErrMsg NCCN_OUT_OF_MEMORY,               "Out of memory in NetComConnection"
AddErrMsg NCCN_DISCONNECTED,                "NetComConnection disconnected"

AddErrMsg NCSP_OUT_OF_MEMORY,               "Out of memory in NetComSvrProtocol"

;WSA GUIDs
WSAID_CONNECTEX            GUID {025A207B9h,0DDF3h,04660h,{08Eh,0E9h,076h,0E5h,08Ch,074h,006h,03Eh}}
;WSAID_ACCEPTEX             GUID {0B5367DF1h,0CBACh,011CFh,{095h,0CAh,000h,080h,05Fh,048h,0A1h,092h}}
;WSAID_DISCONNECTEX         GUID {07FDA2E11h,08630h,0436Fh,{0A0h,031h,0F5h,036h,0A6h,0EEh,0C1h,057h}}
;WSAID_GETACCEPTEXSOCKADDRS GUID {0B5367DF2h,0CBACh,011CFh,{095h,0CAh,000h,080h,05Fh,048h,0A1h,092h}}
;WSAID_TRANSMITFILE         GUID {0B5367DF0h,0CBACh,011CFh,{095h,0CAh,000h,080h,05Fh,048h,0A1h,092h}}
;WSAID_TRANSMITPACKETS      GUID {0D9689DA0h,01F90h,011D3h,{099h,071h,000h,0C0h,04Fh,068h,0C8h,076h}}
;WSAID_WSARECVMSG           GUID {0F689D7C8h,06F1Fh,0436Bh,{08Ah,053h,0E5h,04Fh,0E3h,051h,0C3h,022h}}

SIO_GET_EXTENSION_FUNCTION_POINTER  equ IOC_INOUT or IOC_WS2 or 6

SO_UPDATE_ACCEPT_CONTEXT      equ   700Bh
SO_UPDATE_CONNECT_CONTEXT     equ   7010h

_NETCOMADDR_ struc                          ;Auxiliar structure to get the total size
  union
    SOCKADDR                  {}            ;IPv4
    SOCKADDR_IN               {}            ;IPv4 only
    SOCKADDR_IN6              {}            ;IPv6 only
    SOCKADDR_STORAGE          {}            ;IPv4, IPv6, NetBIOS, infrared or Bluetooth
  ends
_NETCOMADDR_ ends

NETCOMADDR struc                            ;Universal address structure
  wFamily   WORD  ?
  wPort     WORD  ?
  Address   BYTE  sizeof(_NETCOMADDR_) - 2*sizeof(WORD) dup(?)
NETCOMADDR ends
PNETCOMADDR typedef ptr NETCOMADDR


LISTENER struc 4
  hSocket         SOCKET      ?
LISTENER ends
PLISTENER typedef ptr LISTENER

;This structure is not integrated into IO_SOCKJOB to be able to calculate some offsets
IO_HEADER struc 2
  Ovl             OVERLAPPED  {}            ;Must be always the first structure member!
  wOperation      WORD        ?             ;Operation ID, i.e. OPERATION_SOCK_RECV
  wFlags          WORD        ?             ;Flags, i.e. IOF_JOB_LINKED
  dBytesConsumed  DWORD       ?             ;#bytes currently placed in the buffer
IO_HEADER ends
IO_HEADER_SIZE equ sizeof(IO_HEADER)

IO_SOCKJOB struc 4
                  IO_HEADER   {}
                  SDLL_ITEM   {}            ;Linked list to hold buffers together
  WSABuf          WSABUF      {}
  DataBuffer      BYTE        0 dup(?)      ;The data buffer is placed here
IO_SOCKJOB ends                             ;  Minimal size of the buffer must
PIO_SOCKJOB typedef ptr IO_SOCKJOB          ;  be sizeof ACCEPT_DATA

;IO_SOCKJOB databuffer structure for an OPERATION_SOCK_ACCEPT operation
ACCEPT_DATA struct 4
  LocalAddr       BYTE        (sizeof(NETCOMADDR) + 16) dup(?)   ;16 BYTEs added, see AcceptEx
  RemoteAddr      BYTE        (sizeof(NETCOMADDR) + 16) dup(?)   ;  documentation
  pListener       PLISTENER   ?
  pConnection     POINTER     ?
ACCEPT_DATA ends

;WSACF_DONT_REMOVE             equ   BIT00


;Maximum Transmission Unit (MTU) of network hardware in BYTEs
MTU_ETHERNET                  equ   1500
MTU_ETHERNET_JUMBO            equ   9000
MTU_WIFI_80211                equ   2312
MTU_ISDN                      equ   576
MTU_X25                       equ   576
MTU_HYPERCHANNEL              equ   65535

;Maximum Segment Size (MSS) in BYTEs => Application Payload.
;This value can be further reduced if some socket options are enabled.
;Depending on the physical route of the connection, the effective segment size may even be lower.
MSS_ETHERNET_IPV4             equ   MTU_ETHERNET - 40   ;20 Bytes TCP-Header + 20 Bytes IP-Header
MSS_ETHERNET_IPV6             equ   MTU_ETHERNET - 60   ;40 Bytes TCP-Header + 20 Bytes IP-Header

if INTERNET_PROTOCOL_VERSION eq 4
  MSS_ETHERNET_IPVX   equ   MSS_ETHERNET_IPV4
else
  MSS_ETHERNET_IPVX   equ   MSS_ETHERNET_IPV6
endif

; Example: MTU=1500, MSS=1460 (Wireshark)
; 1460 bytes TCP payload (MSS)
; + 20 bytes TCP header
; + 20 bytes IP header
; + 4 bytes Ethernet FCS (depends on capture method)
; = 1504 bytes captured

COMPLETION_KEY_VOID           equ   -1      ;Used to purge the connection
COMPLETION_KEY_KILL_WORKER    equ   -2
COMPLETION_KEY_SOCK_ACCEPTED  equ   -3

AcceptEx proto WIN_STD_CALL_CONV :SOCKET,:SOCKET,:PVOID,:DWORD,:DWORD,:DWORD,:LPDWORD,:LPOVERLAPPED
TYPE_Connectex typedef proto :HANDLE, :POINTER, :DWORD, :POINTER, :DWORD, :POINTER, :LPOVERLAPPED
PTO_CONNECTEX typedef ptr TYPE_Connectex


if TARGET_STR_TYPE eq STR_TYPE_ANSI
  GetHostName equ gethostname
else
  GetHostName equ GetHostNameW
endif

@DefProto DllImport, GetAdaptersAddresses, WIN_STD_CALL_CONV,, <:DWORD, :DWORD, :DWORD, :POINTER, :POINTER>, 20

IP_ADAPTER_UNICAST_ADDRESS struct
  Length_               DWORD     ?
  Flags                 DWORD     ?
  Next                  POINTER   ?
  Address               SOCKET_ADDRESS <>
  PrefixOrigin          DWORD     ?
  SuffixOrigin          DWORD     ?
  DadState              DWORD     ?
  ValidLifetime         DWORD     ?
  PreferredLifetime     DWORD     ?
  LeaseLifetime         DWORD     ?
  OnLinkPrefixLength    BYTE      ?
  _pad                  BYTE      3 dup(?)  ;Alignment
IP_ADAPTER_UNICAST_ADDRESS ends

IP_ADAPTER_ADDRESSES struct
  Length_               DWORD     ?
  IfIndex               DWORD     ?

  Next                  POINTER   ?
  AdapterName           POINTER   ?

  FirstUnicastAddress   POINTER   ?
  FirstAnycastAddress   POINTER   ?
  FirstMulticastAddress POINTER   ?
  FirstDnsServerAddress POINTER   ?

  DnsSuffix             PWSTR     ?
  Description           PWSTR     ?
  FriendlyName          PWSTR     ?

  PhysicalAddress       BYTE      8 dup(?)
  PhysicalAddressLength DWORD     ?

  Flags                 DWORD     ?
  Mtu                   DWORD     ?
  IfType                DWORD     ?
  OperStatus            DWORD     ?

  Ipv6IfIndex           DWORD     ?
  ZoneIndices           DWORD     16 dup(?)

  FirstPrefix           POINTER   ?
IP_ADAPTER_ADDRESSES ends


@DefProto DllImport, GetIpNetTable2, WIN_STD_CALL_CONV,, <:DWORD, :POINTER>, 8
@DefProto DllImport, FreeMibTable, WIN_STD_CALL_CONV,, <:POINTER>, 4

IF_MAX_PHYS_ADDRESS_LENGTH equ  32

MIB_IPNET_ROW2 struct 4
  Address               SOCKADDR_INET <>
  InterfaceIndex        DWORD     ?         ;NET_IFINDEX
  InterfaceLuid         LUID      <>
  PhysicalAddress       UCHAR IF_MAX_PHYS_ADDRESS_LENGTH dup (?)
  PhysicalAddressLength ULONG     ?
  State                 SDWORD    ?         ;NL_NEIGHBOR_STATE
  union
    struct
      IsRouter          BOOLEAN   ?
      IsUnreachable     BOOLEAN   ?
    ends
    Flags               UCHAR     ?
  ends
  union ReachabilityTime
    LastReachable       ULONG     ?
    LastUnreachable     ULONG     ?
  ends
MIB_IPNET_ROW2 ends
PMIB_IPNET_ROW2 typedef ptr MIB_IPNET_ROW2

MIB_IPNET_TABLE2 struct
  NumEntries            DWORD     ?
                        DWORD     ?         ;Alignment 32/64 bit
  Table                 MIB_IPNET_ROW2 0 dup(<>)
MIB_IPNET_TABLE2 ends
PMIB_IPNET_TABLE2 typedef ptr MIB_IPNET_TABLE2


; --------------------------------------------------------------------------------------------------
; Macro:      $htons / $htonl
; Purpose:    Convert a WORD/DWORD to a network port (network byte order = big endian).
; Arguments:  Arg1: Port.

$htons macro Port
  %exitm <((Port and 0ffh) shl 8) or ((Port and 0ff00h) shr 8)>
endm

$htonl macro Port
  %exitm <((Port and 0000000ffh) shl 24) or \
          ((Port and 00000ff00h) shl  8) or \
          ((Port and 000ff0000h) shr  8) or \
          ((Port and 0ff000000h) shr 24)>
endm


DEFAULT_LISTENING_PORT  equ $htons(25773)

;Defaults (can be changed at runtime via your UI/init paths)
TX_HIGH_WM_DEFAULT      equ (4*1024*1024)   ;4 MiB Watermark
TX_LOW_WM_DEFAULT       equ (2*1024*1024)   ;2 MiB Watermark

; --------------------------------------------------------------------------------------------------
; Object:  NetComIOSockJobPool
; Purpose: Implement a DataPool of IOSockJobs. An IOSockJob is a memory chunk with a header structure
;          called IO_SOCKJOB followed by a data buffer.

Object NetComIOSockJobPool, NetComIOSockJobPoolID, DataPool
  RedefineMethod  Init,               POINTER, DWORD, DWORD

  RedefineMethod  NewItem,            WORD
  RedefineMethod  FreeItem,           PIO_SOCKJOB
  RedefineMethod  Reset
  VirtualMethod   ResetIOJob,         PIO_SOCKJOB, WORD

  DefineVariable  dBufferSize,        DWORD,            0     ;Payload size of each Item in BYTEs
  DefineVariable  dCount,             DWORD,            0     ;Control value
ObjectEnd

; --------------------------------------------------------------------------------------------------
; Object:  NetComConnection
; Purpose: Implement a NetCom connection.

Object NetComConnection, NetComConnectionID, Primer
  VirtualMethod   Allow,              DWORD
  VirtualMethod   Close,              DWORD                   ;Graceful/Abortive disconnection
  VirtualMethod   Disconnect,         DWORD                   ;Gracefull disconnect one or both directions
  RedefineMethod  Done
  RedefineMethod  Init,               POINTER, POINTER        ;-> Owner, -> NetComProtocol
  VirtualMethod   FlushRcvIOJobs
  VirtualMethod   TryQueueReceive

  ;Methods to place supervisor jobs
  VirtualMethod   QueueDestroy

  ;Methods to place IO socket jobs or messages on the IOCP queue
  VirtualMethod   QueueAccept,        PLISTENER               ;-> Listener
  VirtualMethod   QueueConnect,       PNETCOMADDR, PNETCOMADDR;-> RemoteAddr, -> LocalAddr
  VirtualMethod   QueueReceive
  VirtualMethod   QueueSend,          POINTER, DWORD          ;-> Data, Size

  ;Methods to marshal completion notifications
  VirtualMethod   OnAccepted,         PIO_SOCKJOB
  VirtualMethod   OnConnected,        PIO_SOCKJOB
  VirtualMethod   OnError,            PIO_SOCKJOB, DWORD      ;-> IO_SockJob, dError
  VirtualMethod   OnReceived,         PIO_SOCKJOB
  VirtualMethod   OnSent,             PIO_SOCKJOB

  ;Methods to (re)issue send/recv jobs
  VirtualMethod   DoReceive,          PIO_SOCKJOB
  VirtualMethod   DoSend,             PIO_SOCKJOB

  ;Data Members
  DefineVariable  ChainItem,          SDLL_ITEM,        {NULL, NULL} ;Link to other Connections
  DefineVariable  dPendingIOJobs,     DWORD,            0     ;Pending IO jobs
  DefineVariable  dCompletedIOJobs,   DWORD,            0     ;Completed IO jobs
  DefineVariable  RcvIOChain,         SDLL_SENTINEL,    {NULL, NULL}  ;Recieve IOSockJob chain
  DefineVariable  dFlags,             DWORD,            NCC_DISCONNECTED_LOCAL
  DefineVariable  dRcvLstElpsdTime,   DWORD,            0     ;Last elapsed time we recieved data (secs)

  ;Networking stuff
  DefineVariable  pProtocol,          POINTER,          NULL
  DefineVariable  hSocket,            SOCKET,           INVALID_SOCKET
  DefineVariable  LocalAddr,          NETCOMADDR,       {AF_INETX}  ;IP + Port
  DefineVariable  RemoteAddr,         NETCOMADDR,       {AF_INETX}  ;IP + Port
  DefineVariable  ConnStartTime,      SYSTEMTIME,       {}

  ;Backpressure Metric
  DefineVariable  dTxQueuedBytes,     DWORD,            0     ;Total queued (in-flight + pending) bytes for WSASend
  DefineVariable  dTxHighWM,          DWORD,            TX_HIGH_WM_DEFAULT
  DefineVariable  dTxLowWM,           DWORD,            TX_LOW_WM_DEFAULT
  DefineVariable  dTxBlocked,         DWORD,            0     ;Boolean: window full reached at least once
  DefineVariable  dRxPaused,          DWORD,            0     ;Boolean: do not post new WSARecv
  DefineVariable  dRxInFlight,        DWORD,            0     ;Number of posted Recv operations (0/1)

  ;Management
  DefineVariable  pData,              POINTER,          NULL  ;-> Data managed by the protocol
  DefineVariable  CritSect,           CRITICAL_SECTION, {}
ObjectEnd

; --------------------------------------------------------------------------------------------------
; Object:  NetComConnectionPool
; Purpose: Implement a DataPool of NetComConnections.

Object NetComConnectionPool, NetComConnectionPoolID, DataPool
  RedefineMethod  Init,               POINTER, DWORD, POINTER
  RedefineMethod  NewItem
  RedefineMethod  FreeItem,           $ObjPtr(NetComConnection)

  DefineVariable  dCount,             DWORD,    0             ;Control value
  DefineVariable  pIOSockJobPool,     $ObjPtr(NetComIOSockJobPool),  NULL
ObjectEnd

; --------------------------------------------------------------------------------------------------
; Object:  NetComAddrCollection
; Purpose: Implement an WinSockAddr collection.

Object NetComAddrCollection,, SortedDataCollection
  RedefineMethod  Compare,            PNETCOMADDR, PNETCOMADDR
  RedefineMethod  Init,               POINTER, DWORD, DWORD, DWORD
  RedefineMethod  Insert,             POINTER
ObjectEnd

; --------------------------------------------------------------------------------------------------
; Object:  NetComProtocol
; Purpose: NetworkProtocol is a base object from which you can derive your own protocol and
;          application specific objects. You can imagine that this object sits inbetween the main
;          NetComEngine object and your application - it is an 'event sink' - its methods are called
;          by the NetComEngine object. Its main job is to enforce the rules of a network
;          protocol, but it can also be used to alert your application about some important events,
;          for example the completion of a Connect attempt. Your application should create one of
;          these objects instances for each network protocol that you wish to support, and hand such
;          instances to the NetComEngine whenever you call NetComEngine.ConnectTo or
;          NetComEngine.Listen...
;          The NetComEngine object will thereafter marshal completed events to the NetComProtocol
;          derived object you provided on a per NetComConnection basis. This implies that each
;          network session can use a different protocol.

Object NetComProtocol, NetComProtocolID, Primer
  VirtualMethod   Allocate,           $ObjPtr(NetComConnection)
  VirtualMethod   AddToBlackList,     PNETCOMADDR                   ;-> NETCOMADDR
  RedefineMethod  Done
  RedefineMethod  Init,               POINTER                       ;-> Owner
  VirtualMethod   IsDataComplete?,    $ObjPtr(NetComConnection), PIO_SOCKJOB
  VirtualMethod   IsBlackListed?,     PNETCOMADDR                   ;-> NETCOMADDR
  VirtualMethod   OnAccepted,         $ObjPtr(NetComConnection)
  VirtualMethod   OnClosed,           $ObjPtr(NetComConnection)
  VirtualMethod   OnConnected,        $ObjPtr(NetComConnection)
  VirtualMethod   OnDisconnected,     $ObjPtr(NetComConnection), DWORD
  VirtualMethod   OnError,            $ObjPtr(NetComConnection), PIO_SOCKJOB, DWORD
  VirtualMethod   OnTimeouted,        $ObjPtr(NetComConnection)
  VirtualMethod   ProcessData,        $ObjPtr(NetComConnection), DWORD ;-> NetComConnection, Index
  VirtualMethod   Release,            $ObjPtr(NetComConnection)

  ;If ClientLocalAddr is set to INADDR_ANY, the server listens on all available network interfaces
  ;Supported service strings are listed here: %WINDIR%\system32\drivers\etc\services
  DefineVariable  ListeningAddr,      NETCOMADDR, {AF_INETX, DEFAULT_LISTENING_PORT}

  ;Timeout in msecs, 0 means no timeout
  DefineVariable  dTimeoutAcp,        DWORD,      0       ;Accept - not implementd yet
  DefineVariable  dTimeoutCon,        DWORD,      0       ;Connect - not implementd yet
  DefineVariable  dTimeoutRcv,        DWORD,      0       ;Recieve
  DefineVariable  dTimeoutSnd,        DWORD,      0       ;Send - not implementd yet

  Embed BlackList, NetComAddrCollection         ;List of addresses that are not allowed to connect
ObjectEnd

; --------------------------------------------------------------------------------------------------
; Object:  NetComEngine
; Purpose: Implement the IOCP core of the NetComEngine.
; Note:    Connections are tracked in a linked list, since they may come from an attack!
;          The supervisor thread should analyse them and eventually close the connections and add
;          the IP addresses to the black list.

Object NetComEngine, NetComEngineID, Primer
  VirtualMethod   ConnectionsClose
  VirtualMethod   ConnectionsDisconnect
  VirtualMethod   ConnectionsDestroy
  VirtualMethod   ConnectTo,          $ObjPtr(NetComProtocol), PNETCOMADDR, PNETCOMADDR
  RedefineMethod  Done
  RedefineMethod  Init,               POINTER, DWORD, DWORD, DWORD
  VirtualMethod   NewConnection,      $ObjPtr(NetComProtocol)
  VirtualMethod   NewAcceptor,        PLISTENER, $ObjPtr(NetComProtocol)
  StaticMethod    Worker
  StaticMethod    Supervisor
  StaticMethod    Startup
  StaticMethod    Shutdown
  VirtualMethod   StartListening,     DWORD, $ObjPtr(NetComProtocol)
  VirtualMethod   StopListening

  DefineVariable  hIOCP,              HANDLE,         0             ;IOCP HANDLE
  DefineVariable  dWorkerCount,       DWORD,          0
  DefineVariable  hSupervisor,        HANDLE,         0             ;Thread HANDLE
  DefineVariable  ConnectionChain,    SDLL_SENTINEL,  {NULL, NULL}
  DefineVariable  dBytesIn,           DWORD,          0
  DefineVariable  dBytesOut,          DWORD,          0
  DefineVariable  dRateIn,            DWORD,          0
  DefineVariable  dRateOut,           DWORD,          0
  DefineVariable  pLocalHostName,     PSTRING,        NULL

  Embed Connections,  NetComConnectionPool              ;Pool of NetComConnections
  Embed Listeners,    DataCollection                    ;DataCollection of listening sockets
  Embed IOSockJobs,   NetComIOSockJobPool               ;IOSockJob Pool
  Embed Workers,      XWCollection                      ;Collection of Worker thread HANDLEs
ObjectEnd


; ==================================================================================================

if IMPLEMENT

; --------------------------------------------------------------------------------------------------
; Purpose:    Debugging macros

DbgOutSockMessage macro WarningText:req, Error, InfoText, Dest
  invoke DbgOutCmd, DBG_CMD_SINGLE_LINE, DbgColorWarning, DbgColorBackground, ??DbgDstWnd
  invoke DbgOutTextA, $OfsCStrA($Esc(<WarningText>)), DbgColorWarning, DbgColorBackground, \
                      DBG_EFFECT_NORMAL, ??DbgDstWnd

  $$Buffersize = 1024
  sub xsp, $$Buffersize                               ;;Reserve a buffer on the stack.
  if TARGET_BITNESS eq 32
    mov edi, esp                                      ;;Get a pointer to the buffer
  else
    lea rdi, [rsp + 28h]                              ;;Get a POINTER to the output buffer
  endif
  invoke wsprintfA, xdi, $OfsCStrA(CRLF, "WSA error code: %lit - "), ebx
  invoke StrEnd, xdi
  mov xsi, xax
  invoke NetErr2StrA, ebx, xax, $$Buffersize - 28h    ;;Get the error message
  mov CHRA ptr [xsi + xax - 2*sizeof(CHRA)], 0        ;;Remove last CHRLF
  invoke DbgOutTextA, xdi, DbgColorWarning, DbgColorBackground, DBG_EFFECT_NORMAL, ??DbgDstWnd
  add xsp, 1024                                       ;;Retrieve the string space
  DbgShowTxtInfo InfoText, ??DbgDstWnd
  DbgShowSrcInfo ??DbgDstWnd
  invoke DbgOutCmd, DBG_CMD_SINGLE_LINE, DbgColorWarning, DbgColorBackground, ??DbgDstWnd
endm

DbgSockError macro WarningText:req, Error, InfoText, Dest
  if DEBUGGING
    DbgSaveContext FALSE, Error
    DbgSetDestWnd Dest
    ifb <Error>
      invoke WSAGetLastError
      mov ebx, eax
    endif
    DbgOutSockMessage WarningText, Error, InfoText, Dest
    DbgLoadContext
  endif
endm

DbgOnSockError macro WarningText:req, Error, InfoText, Dest
  if DEBUGGING
    DbgSaveContext FALSE, Error
    DbgSetDestWnd Dest
    ifb <Error>
      invoke WSAGetLastError
      mov ebx, eax
    endif
    .if ebx != NO_ERROR
      DbgOutSockMessage WarningText, Error, InfoText, Dest
    .endif
    DbgLoadContext
  endif
endm

DbgCheckSockReturn macro QuotedWarningText:req, InfoText, Dest
  if DEBUGGING
    .if eax != NO_ERROR
       DbgSockError QuotedWarningText,, InfoText, Dest
    .endif
  endif
endm


DbgOutComAddrIPV4 macro NetComAddr:req
  invoke DbgOutTextA, $OfsCStrA("Family = "), DbgColorDefaultPre, DbgColorBackground, \
                      DBG_EFFECT_NORMAL, ??DbgDstWnd
  movsx edx, SWORD ptr NetComAddr.NETCOMADDR.wFamily
  invoke sdword2decA, xdi, edx
  invoke DbgOutTextA, xdi, DbgColorDefaultVar, DbgColorBackground, \
                      DBG_EFFECT_NORMAL, ??DbgDstWnd

  invoke DbgOutTextA, $OfsCStrA(", Port = "), DbgColorDefaultPre, DbgColorBackground, \
                      DBG_EFFECT_NORMAL, ??DbgDstWnd
  movzx edx, BYTE ptr NetComAddr.NETCOMADDR.wPort[1]
  mov dh, BYTE ptr NetComAddr.NETCOMADDR.wPort[0]
  invoke udword2decA, xdi, edx
  invoke DbgOutTextA, xdi, DbgColorDefaultVar, DbgColorBackground, \
                      DBG_EFFECT_NORMAL, ??DbgDstWnd

  invoke DbgOutTextA, $OfsCStrA(", IP = "), DbgColorDefaultPre, DbgColorBackground, \
                      DBG_EFFECT_NORMAL, ??DbgDstWnd
  movzx edx, BYTE ptr NetComAddr.NETCOMADDR.Address[0]
  invoke udword2decA, xdi, edx
  invoke DbgOutTextA, xdi, DbgColorDefaultVar, DbgColorBackground, \
                      DBG_EFFECT_NORMAL, ??DbgDstWnd
  invoke DbgOutTextA, $OfsCStrA("."), DbgColorDefaultPre, DbgColorBackground, \
                      DBG_EFFECT_NORMAL, ??DbgDstWnd

  movzx edx, BYTE ptr NetComAddr.NETCOMADDR.Address[1]
  invoke udword2decA, xdi, edx
  invoke DbgOutTextA, xdi, DbgColorDefaultVar, DbgColorBackground, \
                      DBG_EFFECT_NORMAL, ??DbgDstWnd
  invoke DbgOutTextA, $OfsCStrA("."), DbgColorDefaultPre, DbgColorBackground, \
                      DBG_EFFECT_NORMAL, ??DbgDstWnd

  movzx edx, BYTE ptr NetComAddr.NETCOMADDR.Address[2]
  invoke udword2decA, xdi, edx
  invoke DbgOutTextA, xdi, DbgColorDefaultVar, DbgColorBackground, \
                      DBG_EFFECT_NORMAL, ??DbgDstWnd
  invoke DbgOutTextA, $OfsCStrA("."), DbgColorDefaultPre, DbgColorBackground, \
                      DBG_EFFECT_NORMAL, ??DbgDstWnd

  movzx edx, BYTE ptr NetComAddr.NETCOMADDR.Address[3]
  invoke udword2decA, xdi, edx
  invoke DbgOutTextA, xdi, DbgColorDefaultVar, DbgColorBackground, \
                      DBG_EFFECT_NORMAL, ??DbgDstWnd
endm

DbgNetComAddrIPV4 macro NetComAddr:req, InfoText, Dest
  if DEBUGGING
    DbgSaveContext TRUE, NetComAddr
    DbgSetDestWnd Dest
    $$Buffersize = 1024
    sub xsp, $$Buffersize                               ;;Reserve a buffer on the stack.
    if TARGET_BITNESS eq 32
      mov edi, esp                                      ;;Get a pointer to the buffer
    else
      lea rdi, [rsp + 28h]                              ;;Get a POINTER to the output buffer
    endif
    DbgOutComAddrIPV4 [xbx]

    add xsp, $$Buffersize                               ;;Restore stack
    DbgShowTxtInfo InfoText, ??DbgDstWnd
    DbgShowSrcInfo ??DbgDstWnd
    DbgLoadContext
  endif
endm

; --------------------------------------------------------------------------------------------------
; Macro:      $NetworkAddressIPv4
; Purpose:    Convert a string to an IPv4 network address (network byte order = big endian).
; Arguments:  Arg1: String (aaa.bbb.ccc.ddd).

$NetworkAddressIPv4 macro StrAddr:req
  $$Addr = 0
  $$Pos1 = 1
  $$Multiplier = 1
  repeat 3
    $$Pos2 InStr $$Pos1, <StrAddr>, <.>
    $$Addr = $$Addr + $$Multiplier * @SubStr(<&StrAddr>, $$Pos1, $$Pos2 - $$Pos1)
    $$Pos1 = $$Pos2 + 1
    $$Multiplier = 256*$$Multiplier
  endm
  $$Addr = $$Addr + $$Multiplier*@SubStr(<&StrAddr>, $$Pos1)
  %exitm <$$Addr>
endm

; --------------------------------------------------------------------------------------------------
; Macro:      DbgConnection
; Purpose:    Shows NetComConnection internal data.
; Arguments:  Arg1: -> NetComConnection.
;             Arg2: Optional information.
;             Arg3: Optional destination Window name.

DBG_COLOR_FORE_CONNECTION equ DbgColorDefaultVar
DBG_COLOR_BACK_CONNECTION equ DbgColorBackground

DbgConnection macro pConnection:req, InfoText, Dest
  if DEBUGGING
    DbgSaveContext FALSE, pConnection
    assume xax:NOTHING, xbx:NOTHING, xcx:NOTHING, xdx:NOTHING, xdi:NOTHING, xsi:NOTHING
    DbgSetDestWnd Dest
    invoke DbgOutCmd, DBG_CMD_SINGLE_LINE, DBG_COLOR_FORE_CONNECTION, DBG_COLOR_BACK_CONNECTION, ??DbgDstWnd
    ifnb <InfoText>
      invoke DbgOutTextA, $OfsCStrA(<InfoText>), DBG_COLOR_FORE_CONNECTION, DBG_COLOR_BACK_CONNECTION, \
                          DBG_EFFECT_NORMAL, ??DbgDstWnd
    endif
    DbgShowSrcInfo ??DbgDstWnd

    $$Buffersize = 1024
    sub xsp, $$Buffersize                               ;;Reserve a buffer on the stack.
    if TARGET_BITNESS eq 32
      mov esi, esp                                      ;;Get a pointer to the buffer
    else
      lea rsi, [rsp + 28h]                              ;;Get a POINTER to the output buffer
    endif

    mov xdi, xsi
    WriteFA xdi, "Connection = 劣Xh", xbx
    invoke DbgOutTextA, xsi, DBG_COLOR_FORE_CONNECTION, DBG_COLOR_BACK_CONNECTION, \
                        DBG_EFFECT_NEWLINE, ??DbgDstWnd

    FillStringA [xsi], <Connection flags = >
    lea xdi, [xsi + ??StrLen]
    xor eax, eax
    mov edx, [xbx].$Obj(NetComConnection).dFlags
    mov xcx, 32                                         ;;Bits
  @@:
    rcl edx, 1                                          ;;Set bit in carry flag
    setc al
    add al, "0"
    stosb
    loop @B
    mov DCHRA ptr [xdi], "y"                            ;;Set "y" specifier and ZTC
    invoke DbgOutTextA, xsi, DBG_COLOR_FORE_CONNECTION, DBG_COLOR_BACK_CONNECTION, DBG_EFFECT_NEWLINE, ??DbgDstWnd

    mov xdi, xsi
    WriteFA xdi, "Pending IO-Jobs = 各D", [xbx].$Obj(NetComConnection).dPendingIOJobs
    invoke DbgOutTextA, xsi, DBG_COLOR_FORE_CONNECTION, DBG_COLOR_BACK_CONNECTION, \
                        DBG_EFFECT_NEWLINE, ??DbgDstWnd

    mov xdi, xsi
    WriteFA xdi, "Completed IO-Jobs = 各D", [xbx].$Obj(NetComConnection).dCompletedIOJobs
    invoke DbgOutTextA, xsi, DBG_COLOR_FORE_CONNECTION, DBG_COLOR_BACK_CONNECTION, \
                        DBG_EFFECT_NEWLINE, ??DbgDstWnd
;    mov xdi, xsi
;    WriteFA xdi, "Receive last time = 各D seconds", [xbx].$Obj(NetComConnection).dRcvLstElpsdTime
;    invoke DbgOutTextA, xsi, DBG_COLOR_FORE_CONNECTION, DBG_COLOR_BACK_CONNECTION, \
;                        DBG_EFFECT_NEWLINE, ??DbgDstWnd
;
;    mov xdi, xsi
;    WriteFA xdi, "Protocol = 劣Xh", [xbx].$Obj(NetComConnection).pProtocol
;    invoke DbgOutTextA, xsi, DBG_COLOR_FORE_CONNECTION, DBG_COLOR_BACK_CONNECTION, \
;                        DBG_EFFECT_NEWLINE, ??DbgDstWnd

    mov xdi, xsi
    WriteFA xdi, "Socket Handle = 劣X ", [xbx].$Obj(NetComConnection).hSocket
    invoke DbgOutTextA, xsi, DBG_COLOR_FORE_CONNECTION, DBG_COLOR_BACK_CONNECTION, \
                        DBG_EFFECT_NEWLINE, ??DbgDstWnd

    mov xdi, xsi
    DbgOutComAddrIPV4 [xbx].$Obj(NetComConnection).LocalAddr
    invoke DbgOutTextA, $OfsCStrA(", Local address"), DBG_COLOR_FORE_CONNECTION, DBG_COLOR_BACK_CONNECTION, \
                        DBG_EFFECT_NEWLINE, ??DbgDstWnd
    mov xdi, xsi
    DbgOutComAddrIPV4 [xbx].$Obj(NetComConnection).RemoteAddr
    invoke DbgOutTextA, $OfsCStrA(", Remote address"), DBG_COLOR_FORE_CONNECTION, DBG_COLOR_BACK_CONNECTION, \
                        DBG_EFFECT_NEWLINE, ??DbgDstWnd

    add xsp, 1024                                       ;;Retrieve the string space

    invoke DbgOutCmd, DBG_CMD_SINGLE_LINE, DBG_COLOR_FORE_CONNECTION, DBG_COLOR_BACK_CONNECTION, ??DbgDstWnd
    DbgLoadContext
  endif
endm

; ==================================================================================================

include NetComAddrCollection.inc   ;Collection for handling of NETCOMADDR structures
include NetComProtocol.inc         ;Base object for handling of Network Events
include NetComIOSockJobPool.inc    ;Object for recycling of NetComIOJob objects
include NetComConnection.inc       ;This object represents one TCP/IP network session
include NetComConnectionPool.inc   ;Object for recycling of NetComConnections
include NetComEngine.inc           ;The main IOCP object, and IOCP message handler thread

; ==================================================================================================

endif

;  State	      Who is here	  What it means
;  -------------------------------------------
;  CLOSED       Both          No connection
;  LISTEN       Server        Waiting for SYN
;  SYN_SENT     Client        Sent SYN
;  SYN_RECEIVED Server        Got SYN
;  ESTABLISHED  Both          Connected
;  FIN_WAIT_1   Closing side  Sent FIN
;  FIN_WAIT_2   Closing side  FIN acked
;  CLOSE_WAIT   Other side    Received FIN
;  LAST_ACK     Other side    Sent FIN
;  TIME_WAIT    Active closer Cleanup
;  CLOSING      Both          Simultaneous FIN
;
;
;  Mapping WSA calls to TCP states:
;
;  1) Creating a socket
;  WSAStartup(...)
;  socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
;  TCP state: CLOSED
;  At this point the socket exists, but no connection.
;  ________________________________________
;  2) Server side
;  bind + listen -> LISTEN
;  bind(sock, ...);
;  listen(sock, backlog);
;  TCP state: LISTEN
;  The socket is now waiting for incoming connections.
;  ________________________________________
;  accept -> SYN_RECEIVED -> ESTABLISHED
;  clientSock = accept(listenSock, ...);
;  Behind the scenes:
;  Client sends SYN
;  Server enters SYN_RECEIVED
;  Server sends SYN-ACK
;  Client sends ACK
;  TCP state: ESTABLISHED
;  Your accept() only returns once the connection is ESTABLISHED.
;  ________________________________________
;  3) Client side
;  connect -> SYN_SENT -> ESTABLISHED
;  connect(sock, ...);
;  Behind the scenes: SYN_SENT (wait for SYN-ACK) (send ACK)
;  TCP state: ESTABLISHED
;  If successful, connect() returns and the socket is ready.
;  ________________________________________
;  4) Data transfer (ESTABLISHED)
;  send(sock, buf, len, 0);
;  recv(sock, buf, len, 0);
;  TCP state: ESTABLISHED
;  TCP handles segmentation, retransmission, ordering, flow control.
;  ________________________________________
;  5) Half-close with shutdown()
;  shutdown(sock, SD_SEND);   // same as SHUT_WR
;  TCP state: FIN_WAIT_1 -> FIN_WAIT_2
;  You told TCP: "I am done sending, but I can still receive."
;  Peer enters: CLOSE_WAIT
;  ________________________________________
;  6) Full close with closesocket()
;  closesocket(sock);
;  TCP transitions: FIN_WAIT_1 -> FIN_WAIT_2 -> TIME_WAIT -> CLOSED
;  Or on the peer: CLOSE_WAIT -> LAST_ACK -> CLOSED
;  ________________________________________
;  Abortive close (RST)
;  If you do:
;  setsockopt(sock, SOL_SOCKET, SO_LINGER, ...);
;  closesocket(sock);
;  TCP may send: RST
;  Which immediately destroys the connection (no TIME_WAIT).
;  This is an abort, not a graceful close.
;  ________________________________________
;  Error handling via WSA
;  Winsock reports TCP state problems as errors:
;  TCP condition	WSA error
;  Connection reset	WSAECONNRESET
;  Peer closed	recv() returns 0
;  Broken pipe	WSAECONNABORTED
;  Timeout	    WSAETIMEDOUT
;  Unreachable	WSAENETUNREACH
;  ________________________________________
;  Common state-related bugs in WSA apps
;  1) CLOSE_WAIT leak
;  You forgot to call closesocket() after peer closed.
;  Symptom: netstat shows tons of CLOSE_WAIT sockets
;  ________________________________________
;  2) TIME_WAIT exhaustion
;  You open/close thousands of short-lived connections.
;  Symptom: Cannot bind() - address already in use
;  ________________________________________
;  3) Sending after shutdown
;  shutdown(sock, SD_SEND);
;  send(sock, ...);   // -> WSAESHUTDOWN
;  ________________________________________
;  Summary
;  WSA Call	TCP State Effect
;  socket()	CLOSED
;  bind()+listen()	LISTEN
;  connect()	SYN_SENT -> ESTABLISHED
;  accept()	SYN_RECEIVED -> ESTABLISHED
;  send()/recv()	ESTABLISHED
;  shutdown(SD_SEND)	FIN_WAIT_1 -> FIN_WAIT_2
;  closesocket()	LAST_ACK / TIME_WAIT
;  SO_LINGER abort	RST

; ==================================================================================================
; Title:      NetComEngine.inc
; Author:     G. Friedrich
; Version:    C.1.0
; Purpose:    ObjAsm support of NetComEngine objects.
; Notes:      Version C.1.0, October 2017
;               - First release.
; ==================================================================================================


.data
  pConnectEx  POINTER   NULL

if IMPLEMENT

.code
; ==================================================================================================
;    Helper
; ==================================================================================================

; --------------------------------------------------------------------------------------------------
; Procedure:  WsaErrBox
; Purpose:    Auxiliar procedure to to show a WSA error
; Arguments:  Arg1: Parent Window Hnadle.
;             Arg2: -> Message.
;             Arg3: -> Caption.
;             Arg4: MessageBox options.
;             Arg5: WSA Error Code.
; Return:     MessageBox return value.

WsaErrBox proc uses xbx hParent:HWND, pMessage:PSTRING, pCaption:PSTRING, dOptions:DWORD, dError:DWORD
  local cBuffer[4096]:CHR 

  lea xbx, cBuffer
  invoke StrECopy, xbx, pMessage
  invoke StrECopy, xax, offset cCRLF
  invoke StrECopy, xax, offset cCRLF
  invoke StrECopy, xax, $OfsCStr("Description: ")
  mov xdx, xax
  sub xax, xbx
  mov xbx, xdx
  neg xax
  add xax, sizeof cBuffer   
  if sizeof(CHR) eq 2
    shr eax, 1
  endif
  invoke NetErr2Str, dError, xdx, eax                 ;Returns the number of CHRs written
  if sizeof(CHR) eq 2
    shl eax, 1
  endif
  add xbx, xax
  WriteF xbx, "\nError = 各D", dError
  invoke MessageBox, hParent, addr cBuffer, pCaption, dOptions
  ret
WsaErrBox endp


; ==================================================================================================
;    ListenerCollection implementation
; ==================================================================================================

; --------------------------------------------------------------------------------------------------
; Method:     ListenerCollection.DestroyItem
; Purpose:    Auxiliar function to dispose a listener from the collection. Don't call directly!
; Arguments:  Arg1: -> Listener.
; Return:     Nothing.

Method ListenerCollection.DestroyItem, uses xbx, pListener:PLISTENER
  local Linger:linger

  DbgText "ListenerCollection.DestroyItem"
  mov xbx, pListener
  .if xbx != NULL
    .if [xbx].LISTENER.hSocket != INVALID_SOCKET
      ;Perform an "abortive close" of the socket, just in case.
      mov Linger.l_onoff, 1
      mov Linger.l_linger, 0
      invoke setsockopt, [xbx].LISTENER.hSocket, SOL_SOCKET, SO_LINGER, \
                         addr Linger, sizeof Linger
      DbgOnSockError "ListenerCollection.DestroyItem - ERROR on SetSockOpt SO_LINGER"
      invoke closesocket, [xbx].LISTENER.hSocket
    .endif
    MemFree xbx                                         ;Frees data from heap
  .endif
MethodEnd



; ==================================================================================================
;    NetComEngine implementation
; ==================================================================================================

; --------------------------------------------------------------------------------------------------
; Method:     NetComEngine.ConnectionsClose
; Purpose:    Closes all connections.
; Arguments:  None.
; Return:     Nothing.

Method NetComEngine.ConnectionsClose, uses xbx xdi xsi
  SetObject xsi
  LockObjectAccess [xsi].Connections                    ;ConnectionChain should not change!
  lea xdi, [xsi].ConnectionChain                        ;xdi -> SENTINEL
  mov xbx, [xdi].SDLL_SENTINEL.pFirstItem               ;Get first Item
  .while xbx != xdi                                     ;Empty?
    lea xcx, [xbx - offset($Obj(NetComConnection).ChainItem)]
    mov xbx, [xbx].SDLL_ITEM.pNextItem
    OCall xcx::NetComConnection.Close, FALSE
  .endw
  UnlockObjectAccess [xsi].Connections
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComEngine.ConnectionsDestroy
; Purpose:    Destroy all connections.
; Arguments:  None.
; Return:     Nothing.

Method NetComEngine.ConnectionsDestroy, uses xbx xdi xsi
  SetObject xsi
  LockObjectAccess [xsi].Connections                    ;ConnectionChain should not change!
  lea xdi, [xsi].ConnectionChain                        ;xdi -> SENTINEL
  mov xbx, [xdi].SDLL_SENTINEL.pFirstItem               ;Get first Item
  .while xbx != xdi                                     ;Empty?
    lea xcx, [xbx - offset($Obj(NetComConnection).ChainItem)] 
    mov xbx, [xbx].SDLL_ITEM.pNextItem
    OCall xcx::NetComConnection.QueueDestroy
  .endw
  SDLL_Init xdi                                         ;Reset the chain 
UnlockObjectAccess [xsi].Connections
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComEngine.ConnectionsDisconnect
; Purpose:    Disconnects all connections.
; Arguments:  None.
; Return:     Nothing.

Method NetComEngine.ConnectionsDisconnect, uses xbx xdi xsi
  SetObject xsi
  LockObjectAccess [xsi].Connections                    ;ConnectionChain should not change!
    lea xdi, [xsi].ConnectionChain                      ;xdi -> SENTINEL
    mov xdx, [xdi].SDLL_SENTINEL.pFirstItem             ;Get first Item
    .while xdx != xdi
      mov xbx, [xdx].SDLL_ITEM.pNextItem
      lea xcx, [xdx - offset($Obj(NetComConnection).ChainItem)]
      OCall xcx::NetComConnection.Disconnect, SD_SEND
      mov xdx, xbx
    .endw
  UnlockObjectAccess [xsi].Connections
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComEngine.ConnectTo
; Purpose:    Creates a NetComConnection and initiates a Connect attempt.
; Arguments:  Arg1: -> Protocol object.
;             Arg2: -> Remote address.
;             Arg2: -> Local address.
; Return:     xax -> New NetComConnection or NULL if failed.
;             ecx = Error code.

Method NetComEngine.ConnectTo, uses xbx xsi, pProtocol:$ObjPtr(NetComProtocol), \
                                             pRemoteAddr:PNETCOMADDR, \
                                             pLocalAddr:PNETCOMADDR
  SetObject xsi
  ;Get a new NetComConnection and (re)initialize it.
  ?mov xdx, pProtocol
  OCall xsi.NewConnection, xdx
  .if xax != NULL
    mov xbx, xax
    OCall xbx::NetComConnection.QueueConnect, pRemoteAddr, pLocalAddr
    mov ecx, eax                                        ;ecx = error code
    mov xax, xbx                                        ;Return xax -> NetComConnection
  .endif
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComEngine.Done
; Purpose:    Finalizes the NetComEngine object.
; Arguments:  None.
; Return:     Nothing.

Method NetComEngine.Done, uses xdi xsi
  local dThreadExitCode:DWORD

  SetObject xsi

  ;Close all connections
  OCall xsi.ConnectionsDestroy

  ;Close listener sockets and release DataCollection structures
  OCall [xsi].Listeners::DataCollection.Done

  ;Tell NetComEngine worker to die, and wait for the death. Then shutdown the supervisor thread.
  DbgText "NetComEngine.Done - Closing Workers"
  .ColForEach [xsi].Workers
    invoke PostQueuedCompletionStatus, [xsi].hIOCP, 0, COMPLETION_KEY_KILL_WORKER, NULL
  .ColNext

  invoke WaitForMultipleObjects, [xsi].Workers.dCount, [xsi].Workers.pItems, TRUE, 4000
  .if eax == WAIT_TIMEOUT
    DbgWarning "NetComEngine.Done - Brute force worker close"
    .ColForEach [xsi].Workers
      mov xdi, xax
      invoke GetExitCodeThread, HANDLE ptr [xdi], addr dThreadExitCode
      .if eax != 0 && dThreadExitCode == STILL_ACTIVE
        invoke TerminateThread, HANDLE ptr [xdi], -1
        ;IMPORTANT: calling TerminateThread can left synchronization objects in an
        ;           undefined state. Don't call an Debug macro after this point,
        ;           since you can hang the server application!
      .endif
    .ColNext
  .endif
  OCall [xsi].Workers::XWCollection.Done

  invoke WaitForSingleObject, [xsi].hSupervisor, 4000
  .if eax == WAIT_TIMEOUT
    invoke TerminateThread, [xsi].hSupervisor, -1
  .endif

  ;Destroy IOCP
  invoke CloseHandle, [xsi].hIOCP

  ;Clean up resource pools
  OCall [xsi].IOSockJobs::NetComIOSockJobPool.Done
  OCall [xsi].Connections::NetComConnectionPool.Done

  ;Housekeeping
  Invoke StrDispose, [xsi].pLocalHostName
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComEngine.Init
; Purpose:    Initializes internal collections, threads, IOCP etc.
; Arguments:  Arg1: -> Owner object.
;             Arg2: Number of preallocated connections.
;             Arg3: Number of preallocated IO_SOCKJOBs.
;             Arg4: IO socket buffer size, usually the "Maximum Segment Size" (MSS).
; Return:     eax = 0 if succeeded, otherwise an error code.

Method NetComEngine.Init, uses xbx xsi, pOwner:POINTER, \
                                        dAllocConnections:DWORD, dAllocIOSockJobs:DWORD, \
                                        dSockBufferSize:DWORD
  local dRetValue:DWORD, SysInfo:SYSTEM_INFO, cLocalHostName[256]:CHR    ;Max. 256 characters

  SetObject xsi

  ACall xsi.Init, pOwner
  mov dRetValue, NO_ERROR
  lea xax, [xsi].ConnectionChain
  SDLL_Init xax

  ;Override Listeners methods
  Override [xsi].Listeners::DataCollection.DestroyItem, ListenerCollection.DestroyItem

  ;Get the local host name
  invoke GetHostName, addr cLocalHostName, lengthof cLocalHostName
  mov [xsi].pLocalHostName, $invoke(StrNew, addr cLocalHostName)

  ;Initialize the collections
  lea xbx, [xsi].IOSockJobs                             ;xbx -> NetComIOSockJobPool
  OCall xbx::NetComIOSockJobPool.Init, xsi, dAllocIOSockJobs, dSockBufferSize
  OCall [xsi].Connections::NetComConnectionPool.Init, xsi, dAllocConnections, xbx
  OCall [xsi].Listeners::DataCollection.Init, xsi, 5, 5, COL_MAX_CAPACITY
  invoke GetSystemInfo, addr SysInfo
  mrm [xsi].dWorkerCount, SysInfo.dwNumberOfProcessors, eax   ;Number of logical processors
  OCall [xsi].Workers::XWCollection.Init, xsi, eax, 0, eax

  ;Create the IOCP
  mov [xsi].hIOCP, $invoke(CreateIoCompletionPort, INVALID_HANDLE_VALUE, 0, 0, [xsi].dWorkerCount)
  .if xax == 0
    OCall xsi.ErrorReport, NULL, NCE_IOCP_INIT_ERROR
    mov dRetValue, $32($invoke(WSAGetLastError))
    DbgSockError "NetComEngine.Init - Failed to create the IOCP", dRetValue
    jmp @@Exit
  .endif
  ;Create supervisor thread
  invoke CreateThread, 0, 16*1024, $MethodAddr(NetComEngine.Supervisor), xsi, 0, NULL
  .if xax == 0
    mov dRetValue, $32($invoke(GetLastError))
    OCall xsi.ErrorReport, NULL, NCE_THREAD_CREATION_FAILED
    DbgSockError "NetComEngine.Init - Failed to create supervisor thread", dRetValue
    jmp @@Exit
  .endif
  mov [xsi].hSupervisor, xax

  ;Create a Worker Thread per available "logical" cpu
  mov ebx, [xsi].dWorkerCount
  test ebx, ebx
  .while !ZERO?
    invoke CreateThread, 0, 16*1024, $MethodAddr(NetComEngine.Worker), xsi, 0, NULL
    .if xax == 0
      mov dRetValue, $32($invoke(GetLastError))
      OCall xsi.ErrorReport, NULL, NCE_THREAD_CREATION_FAILED
      DbgSockError "NetComEngine.Init - Failed to create worker thread", dRetValue
      jmp @@Exit
    .endif
    DbgHex xax, "NetComEngine.Init - New Worker"
    OCall [xsi].Workers::XWCollection.Insert, xax
    dec ebx
  .endw

@@Exit:
  mov eax, dRetValue
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComEngine.NewAcceptor
; Purpose:    Creates a new NetComConnection and enqueues an accept IOSockJob using a new protocol.
; Arguments:  Arg1: -> Listener.
;             Arg2: -> NetComProtocol.
; Return:     eax = Zero if succeeded, otherwise an error code.

Method NetComEngine.NewAcceptor, uses xbx xsi, pListener:PLISTENER, pProtocol:$ObjPtr(NetComProtocol)
  SetObject xsi
  OCall [xsi].Connections::NetComConnectionPool.NewItem ;Get a new NetComConnection from the pool
  .if xax == NULL
    mov eax, WSA_NOT_ENOUGH_MEMORY
  .else
    mov xbx, xax
    OCall xbx::NetComConnection.Init, addr [xsi].Connections, pProtocol
    OCall xbx::NetComConnection.QueueAccept, pListener  ;Queue the accept job
;    DbgHex xbx, "NetComEngine.NewAcceptor"
  .endif
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComEngine.NewConnection
; Purpose:    Creates a NetComConnection.
; Arguments:  Arg1: -> protocol object.
; Return:     xax -> new NetComConnection or NULL if failed.
; Notes:      This method is useful for creating sockets with arbitrary semantics.
;             Use this for 'connectionless' socket types.

Method NetComEngine.NewConnection, uses xbx xsi, pProtocol:$ObjPtr(NetComProtocol)
  SetObject xsi
  OCall [xsi].Connections::NetComConnectionPool.NewItem
  .if xax != NULL
    mov xbx, xax
    OCall xbx::NetComConnection.Init, addr [xsi].Connections, pProtocol
    .if eax == 0                                        ;Zero means success
      ;Register the socket with IOCP, because we want socket event notifications
      invoke CreateIoCompletionPort, [xbx].$Obj(NetComConnection).hSocket, [xsi].hIOCP, xbx, 0
      mov xax, xbx
    .else
      ;Failed to initialize new connection
      OCall [xsi].Connections::NetComConnectionPool.FreeItem, xbx
      xor eax, eax
    .endif
  .endif
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComEngine.Supervisor
; Purpose:    This thread is responsible making all administrative work on the engine.
; Arguments:  None.
; Return:     Nothing.

Method NetComEngine.Supervisor, uses xbx xdi xsi
  local dConnectionTime:DWORD, dConnectionTimeSize:DWORD, SW:$Obj(StopWatch)
  local dLastBytesIn:DWORD, dLastBytesOut:DWORD, dBytesIn:DWORD, dBytesOut:DWORD, dElapsedTime:DWORD
  local pConnection:$ObjPtr(NetComConnection)

  SetObject xsi
  mov dConnectionTimeSize, sizeof dConnectionTime
  New SW::StopWatch
  OCall xax::StopWatch.Init, xsi
  m2z DWORD ptr [SW.$Obj(StopWatch).r8Resolution]
  mov DWORD ptr [SW.$Obj(StopWatch).r8Resolution + 4], 408F4000h    ;REAL8 = 1000.0
  m2z dLastBytesIn
  m2z dLastBytesOut

  .repeat
    OCall SW::StopWatch.Reset
    OCall SW::StopWatch.Start
    LockObjectAccess [xsi].$Obj(NetComEngine).Connections

      lea xdi, [xsi].ConnectionChain
      mov xbx, [xdi].SDLL_SENTINEL.pFirstItem
      .while xbx != xdi                                             ;Check for end of chain
        lea xbx, [xbx - offset $Obj(NetComConnection).ChainItem]    ;xbx -> NetComConnection instance
        mov pConnection, xbx

        .ifBitClr [xbx].$Obj(NetComConnection).dFlags, NCC_CLOSED
          ;Check all open connections for a possible attack
          ;We want to check if a NetComConnection timeouts

;          .if [xbx].$Obj(NetComConnection).dRcvLstElpsdTime != -1           ;Only established connections
;            .if [xbx].$Obj(NetComConnection).ObjLock.dLockCount == 0    ;Skip locked connections
;              .ifBitClr [xbx].$Obj(NetComConnection).dFlags, NCC_ABORT  ;Not processed before?
;                invoke getsockopt, [xbx].$Obj(NetComConnection).hSocket, SOL_SOCKET, SO_CONNECT_TIME, \
;                                   addr dConnectionTime, addr dConnectionTimeSize
;                DbgOnSockError "ERROR on getsockopt SO_CONNECT_TIME"
;                mov eax, dConnectionTime
;                sub eax, [xbx].$Obj(NetComConnection).dRcvLstElpsdTime
;                mov xcx, [xbx].$Obj(NetComConnection).pProtocol
;                mov edx, [xcx].$Obj(NetComProtocol).dTimeoutRcv
;                .if edx != 0 && eax >= edx
;                  OCall xcx::NetComProtocol.OnTimeouted, xbx
;                  .if eax == PROT_CMD_CLOSE
;                    OCall xbx::NetComConnection.QueueDestroy
;                  .endif
;                .endif
;              .endif
;            .endif
;          .endif
        .endif

;        ;Check for disconnection or closure
;        mov eax, [xbx].$Obj(NetComConnection).dFlags
;        .ifBitClr eax, NCC_DESTROYED
;          .ifBitSet eax, NCC_DESTROY_QUEUED
;            and eax, NCC_DISCONNECTED
;            .if eax == NCC_DISCONNECTED
;              .if [xbx].$Obj(NetComConnection).dPendingIOJobs == 0
;                OCall xbx::NetComConnection.Reset
;              .endif
;            .endif
;          .endif
;        .endif
;
;        mov eax, [xbx].$Obj(NetComConnection).dFlags
;
        ;Move to next Connection now, in case xbx is freed by the coming code
        mov xbx, POINTER ptr [xbx + offset $Obj(NetComConnection).ChainItem]
;
;        .ifBitClr eax, NCC_FREED
;          .ifBitSet eax, NCC_FREE_QUEUED
;            .ifBitClr eax, NCC_DESTROYED
;              and eax, NCC_DISCONNECTED
;              .if eax == NCC_DISCONNECTED
;                OCall pConnection::NetComConnection.Reset
;              .endif
;            .endif
;            OCall xsi.FreeConnection, pConnection
;          .endif
;        .endif

      .endw

    UnlockObjectAccess [xsi].$Obj(NetComEngine).Connections
    invoke Sleep, 500

    ;Compute input and output transfer rates
    OCall SW::StopWatch.Stop
    OCall SW::StopWatch.GetTime                                 ;edx should be always zero
    mov dElapsedTime, eax

    mrm dBytesIn, [xsi].dBytesIn, eax
    sub eax, dLastBytesIn                                       ;Get net value
    shl eax, 3                                                  ;Convert to bits
    m2m dLastBytesIn, dBytesIn, edx                             ;Save value
    xor edx, edx                                                ;Prep for div
    div dElapsedTime
    mov [xsi].dRateIn, eax

    mrm dBytesOut, [xsi].dBytesOut, eax
    sub eax, dLastBytesOut                                      ;Get net value
    shl eax, 3                                                  ;Convert to bits
    m2m dLastBytesOut, dBytesOut, edx                           ;Save value
    xor edx, edx                                                ;Prep for div
    div dElapsedTime
    mov [xsi].dRateOut, eax

  .until [xsi].Workers.dCount == 0

  OCall SW::StopWatch.Done
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComEngine.StartListening
; Purpose:    Creates a "Listener" and begins listening on a port (Service) using a protocol.
; Arguments:  Arg1: Number of preallocated accept connections.
;             Arg2: -> NetComProtocol.
; Return:     eax = Zero if succeeded, otherwise an error code.

Method NetComEngine.StartListening, uses xbx xdi xsi, dAcceptorCount:DWORD, pProtocol:$ObjPtr(NetComProtocol)
  local dOption:DWORD, dRetValue:DWORD

  DbgText "NetComEngine.StartListening"
  SetObject xsi
  mov dRetValue, NO_ERROR

  ;Create a socket with WSA_FLAG_OVERLAPPED flag!
  MemAlloc sizeof(LISTENER)
  .if xax == NULL
    mov dRetValue, WSA_NOT_ENOUGH_MEMORY
    DbgSockError "NetComEngine.StartListening - Can not allocate LISTENER structure", dRetValue
    jmp @@Exit
  .endif
  mov xbx, xax
  mov [xbx].LISTENER.hSocket, INVALID_SOCKET
  OCall [xsi].Listeners::DataCollection.Insert, xbx

  invoke WSASocket, AF_INETX, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED
  .if xax == INVALID_SOCKET
    mov dRetValue, $32($invoke(WSAGetLastError))
    DbgSockError "NetComEngine.StartListening - Failed to create listener socket", dRetValue
    OCall xsi.ErrorReport, NULL, NCE_SOCKET_CREATION_FAILED
    jmp @@Exit
  .endif
  mov [xbx].LISTENER.hSocket, xax
  DbgText "NetComEngine.StartListening - Listener socket created"

  ;Set socket options: disable nagle's algorithm for fast reaction time
  mov dOption, 1                                        ;1 means algo disabled
  invoke setsockopt, [xbx].LISTENER.hSocket, IPPROTO_TCP, TCP_NODELAY, \
                     addr dOption, sizeof dOption
  DbgCheckSockReturn "NetComEngine.StartListening - ERROR on SetSockOpt TCP_NODELAY = 1"

  mov xdi, pProtocol
  invoke bind, [xbx].LISTENER.hSocket, addr [xdi].$Obj(NetComProtocol).ListeningAddr, \
               sizeof NETCOMADDR
  .if xax != NO_ERROR
    mov dRetValue, $32($invoke(WSAGetLastError))
    DbgSockError "NetComEngine.StartListening - Failed to bind listener socket", dRetValue
    OCall pProtocol::NetComProtocol.OnError, NULL, NULL, dRetValue
    OCall xsi.ErrorReport, NULL, NCE_LISTENER_BIND_ERROR
    jmp @@Exit
  .endif

  DbgText "NetComEngine.StartListening - SocketAddress has been bound to listener socket"
  invoke listen, [xbx].LISTENER.hSocket, SOMAXCONN
  .if eax != NO_ERROR
    mov dRetValue, $32($invoke(WSAGetLastError))
    DbgSockError "NetComEngine.StartListening - Listener socket failed to listen", dRetValue
    OCall pProtocol::NetComProtocol.OnError, NULL, NULL, dRetValue
    OCall xsi.ErrorReport, NULL, NCE_LISTENER_DOESNT_LISTEN
    jmp @@Exit
  .endif

  DbgText "NetComEngine.StartListening - Socket is listening..."
  ;Bind the listening socket to the IOCP => necessary for acceptor
  invoke CreateIoCompletionPort, [xbx].LISTENER.hSocket, [xsi].hIOCP, \
                                 COMPLETION_KEY_SOCK_ACCEPTED, 0
  .if xax == 0                                          ;0 means failure
    mov dRetValue, $32($invoke(GetLastError))
    DbgSockError "NetComEngine.StartListening - Listener can not de bound to the IOCP", dRetValue
    OCall pProtocol::NetComProtocol.OnError, NULL, NULL, eax
    OCall xsi.ErrorReport, NULL, NCE_LISTENER_IOCP_BIND_FAILED
    jmp @@Exit
  .endif

  DbgText "NetComEngine.StartListening - Socket has been bound to IOCP"
  ;Queue some accept NetComConnections
  mov edi, dAcceptorCount
  test edi, edi
  .while !ZERO?
    OCall xsi.NewAcceptor, xbx, pProtocol               ;Returns eax = error code
    .break .if eax != NO_ERROR && eax != ERROR_IO_PENDING
    dec xdi
  .endw

@@Exit:
  mov eax, dRetValue
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComEngine.Startup
; Purpose:    WinSock startup.
; Arguments:  None.
; Return:     Nothing.
; Note:       The WinSock startup is placed here so that other related APIs will work before the
;             NetComEngine is started.

Method NetComEngine.Startup
  local WsaData:WSADATA, hSocket:SOCKET, dBytesTransf:DWORD

  invoke WSAStartup, 0202h, addr WsaData
  .if eax != 0
    ;Write the error code into the NetComEngine template.
    ;New instances inherit this error code and must check it.
    OCall $ObjTmpl(NetComEngine)::NetComEngine.ErrorSet, NCE_WINSOCK_INIT_FAILED
  .endif

  invoke WSASocket, AF_INETX, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED
  .if xax != 0
    mov hSocket, xax

    ;Try to obtain a POINTER to the ConnectEx procedure, which may change from socket to socket
    invoke WSAIoctl, hSocket, SIO_GET_EXTENSION_FUNCTION_POINTER,
                     offset WSAID_CONNECTEX, sizeof WSAID_CONNECTEX,
                     addr pConnectEx, sizeof POINTER,
                     addr dBytesTransf, NULL, NULL
    .if eax != NO_ERROR
      DbgWarning "NetComEngine.Startup - Failed to get and address of the procedure ConnextEx"
    .endif
    invoke closesocket, hSocket
  .endif
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComEngine.Shutdown
; Purpose:    WinSock Shutdown.
; Arguments:  None.
; Return:     Nothing.

Method NetComEngine.Shutdown
  invoke WSACleanup
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComEngine.StopListening
; Purpose:    Stops the engine.
; Arguments:  None.
; Return:     Nothing.

Method NetComEngine.StopListening, uses xsi

  DbgText "NetComEngine.StopListening"
  SetObject xsi

  ;Close all listerners
  DbgText "NetComEngine.StopListening - Closing listeners"

  ;Closes all listening sockets. Pending IOs are cancelled through the IOCP,
  ;which frees the associated acceptor connections.
  OCall [xsi].Listeners::DataCollection.DisposeAll
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComEngine.Worker
; Purpose:    Here is the HEART AND SOUL of the NetComEngine.
;             This thread is responsible for waiting on IOCP completion notifications and passing
;             them to the corresponding method.
;             There can be several of these Worker threads operating asynchronously.
; Arguments:  None.
; Return:     Nothing.

Method NetComEngine.Worker, uses xbx xdi xsi
  local pIOSockJob:PIO_SOCKJOB, xCompletionKey:XWORD, dBytesTransfered:DWORD
  local dFlags:DWORD, dBytesConsumed:DWORD, dOvrResult:DWORD

  SetObject xsi
  .while TRUE
    ;The GetQueuedCompletionStatus API call will (if successful) return two useful pieces of
    ;information. One is the "completion key" of the completed IO, the other is a POINTER
    ;to the IOSockJob which represents the IO operation which was completed.
    invoke GetQueuedCompletionStatus, [xsi].hIOCP, addr dBytesTransfered,
                                                   addr xCompletionKey,
                                                   addr pIOSockJob,
                                                   INFINITE
    .break .if xCompletionKey == COMPLETION_KEY_KILL_WORKER   ;Exit thread loop immediately
    mov xbx, pIOSockJob
    .if xbx != NULL
      .if xCompletionKey == COMPLETION_KEY_VOID
        mov xdi, xbx                                    ;pConnection passed using pIOSockJob
        DbgHex xdi, "NetComEngine.Worker - Void posted"
      .else
        .if xCompletionKey == COMPLETION_KEY_SOCK_ACCEPTED
          mov xdi, [xbx].IO_SOCKJOB.DataBuffer.ACCEPT_DATA.pConnection
;          DbgHex xdi, "NetComEngine.Worker - Listener detected an incomming connection - accept connection"
        .else
          mov xdi, xCompletionKey                       ;xdi -> NetComConnection
        .endif
      .endif
;      DbgHex xdi, "NetComEngine.Worker - Connection"
      invoke EnterCriticalSection, addr [xdi].$Obj(NetComConnection).CritSect

      ;Determine whether the operation completed successfully or not
      invoke WSAGetOverlappedResult, [xdi].$Obj(NetComConnection).hSocket, xbx, \
                                     addr dBytesConsumed, \
                                     FALSE, addr dFlags
      mov dOvrResult, eax
      ;Serialize on a per connection basis
;      LockObjectAccess [xdi].$Obj(NetComConnection)
      BitSet [xbx].IO_SOCKJOB.wFlags, IOF_JOB_COMPLETED
      lock dec [xdi].$Obj(NetComConnection).dPendingIOJobs
      lock inc [xdi].$Obj(NetComConnection).dCompletedIOJobs
      .if dOvrResult != FALSE
        ;Operation succeeded *****************************************************************
        ;Each of the following connection handlers must manage the IOSockJob themselves
        movzx eax, [xbx].IO_SOCKJOB.wOperation
        .if eax == OPERATION_SOCK_RECV
          mrm [xbx].IO_SOCKJOB.dBytesConsumed, dBytesConsumed, edx
          lock add [xsi].dBytesIn, edx
          OCall xdi::NetComConnection.OnReceived, xbx

        .elseif eax == OPERATION_SOCK_SEND
          mrm [xbx].IO_SOCKJOB.dBytesConsumed, dBytesConsumed, edx
          lock add [xsi].dBytesOut, edx
          OCall xdi::NetComConnection.OnSent, xbx

        .elseif eax == OPERATION_SOCK_CONNECT
          OCall xdi::NetComConnection.OnConnected, xbx

        .elseif eax == OPERATION_SOCK_ACCEPT
          OCall xdi::NetComConnection.OnAccepted, xbx

        .else
          invoke WSAGetLastError                        ;This error is thread specific
          OCall xdi::NetComConnection.OnError, xbx, eax
        .endif

      .else
        ;Operation failed! *******************************************************************
        invoke WSAGetLastError                          ;This error is thread specific
        OCall xdi::NetComConnection.OnError, xbx, eax
      .endif

      ;If the connection is flagged for destruction, proceed ONLY if the 
      ;connection has no pending IOs
      .ifBitSet [xdi].$Obj(NetComConnection).dFlags, NCC_DESTROY_QUEUED
        .if [xdi].$Obj(NetComConnection).dPendingIOJobs == 0
          OCall xdi::NetComConnection.Done
          OCall [xsi].Connections::NetComConnectionPool.FreeItem, xdi
        .endif
      .endif

;      UnlockObjectAccess [xdi].$Obj(NetComConnection)
      invoke LeaveCriticalSection, addr [xdi].$Obj(NetComConnection).CritSect
    .endif

  .endw

  DbgText "NetComEngine.Worker - death"
  DbgDec [xsi].IOSockJobs.dCount, "NetComEngine.Worker"
MethodEnd

endif

; ==================================================================================================
; Title:      NetComConnection.inc
; Author:     G. Friedrich
; Version:    C.1.0
; Purpose:    ObjAsm support of NetComConnection objects.
; Notes:      Version C.1.0, October 2017
;               - First release.
; ==================================================================================================


.code

if IMPLEMENT

; ==================================================================================================
;    NetComConnection implementation
; ==================================================================================================

; --------------------------------------------------------------------------------------------------
; Method:     NetComConnection.Allow
; Purpose:    Performs internal setup work after an accept was detected. Depending in the argument
;             value, the connection is established or discarded.
; Arguments:  Arg1: TRUE/FALSE.
; Return:     Nothing.

Method NetComConnection.Allow, uses xsi, dTrueOrFalse:DWORD
  SetObject xsi
;  DbgHex xsi, "NetComConnection.Allow"
  mov xcx, [xsi].pOwner                                 ;xcx -> NetComConnectionPool
  mov xax, [xcx].$Obj(NetComConnectionPool).pOwner      ;xax -> NetComEngine
  .if dTrueOrFalse != FALSE
    ;Bind the NetComConnection Socket to the IOCP
    invoke CreateIoCompletionPort, [xsi].hSocket, [xax].$Obj(NetComEngine).hIOCP, xsi, 0
    invoke GetSystemTime, addr [xsi].ConnStartTime
    OCall xsi.QueueReceive
  .else
    ;Connection rejected
    OCall xsi.QueueDestroy                              ;Mark to free => close & free
    OCall xsi.Close, FALSE
  .endif
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComConnection.Close
; Purpose:    Perform an graceful disconnection of a NetCom connection sending a FIN/RST to the
;             remote endpoint.
; Arguments:  Arg1: Abortive flag (TRUE/FALSE).
; Return:     Nothing.

Method NetComConnection.Close, uses xsi, dAbortive:DWORD
  local Linger:linger

  SetObject xsi
;  DbgHex xsi, "NetComConnection.Close"
  .ifBitClr [xsi].dFlags, NCC_CLOSED
    ;Perform a "graceful" or "abortive" disconnection of the socket sending a "FIN" or "RST"
    ;to the remote endpoint
    ?mov edx, dAbortive
    mov Linger.l_onoff, dx                              ;Linger ON/OFF
    mov Linger.l_linger, 0                              ;Wait time = 0
    invoke setsockopt, [xsi].hSocket, SOL_SOCKET, SO_LINGER, addr Linger, sizeof Linger
    DbgCheckSockReturn "NetComConnection.Close - ERROR on SetSockOpt SO_LINGER"
    xBitSet [xsi].dFlags, NCC_CLOSED                    ;Set marker
    invoke closesocket, [xsi].hSocket
    mov [xsi].hSocket, INVALID_SOCKET
    OCall [xsi].pProtocol::NetComProtocol.OnClosed, xsi
  .endif
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComConnection.Disconnect
; Purpose:    Disconnect writing and/or reading.
; Arguments:  Arg1: Disconnect direction = SD_SEND/SD_RECEIVE/SD_BOTH
; Return:     Nothing.

Method NetComConnection.Disconnect, uses xsi, dDirection:DWORD
  SetObject xsi
;  DbgHex xsi, "NetComConnection.Disconnect"
  .ifBitClr [xsi].dFlags, NCC_CLOSED
    invoke shutdown, [xsi].hSocket, dDirection            ;Send FIN to the remote host
;    DbgCheckSockReturn "NetComConnection.Disconnect - shutdown error"
    .if eax == NO_ERROR
      .if dDirection == SD_RECEIVE
        xBitSet [xsi].dFlags, NCC_SHUTDOWN_RX_LOCAL
      .elseif dDirection == SD_SEND
        xBitSet [xsi].dFlags, NCC_SHUTDOWN_TX_LOCAL
      .else
        xBitSet [xsi].dFlags, NCC_SHUTDOWN_RX_LOCAL or NCC_SHUTDOWN_TX_LOCAL
      .endif
      OCall [xsi].pProtocol::NetComProtocol.OnDisconnected, xsi, dDirection
    .endif
  .endif
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComConnection.Done
; Purpose:    Finalize the NetComConnection object.
; Arguments:  None.
; Return:     Nothing.

Method NetComConnection.Done, uses xsi
  SetObject xsi
;  DbgHex xsi, "NetComConnection.Done **************************************************************"
  OCall xsi.Close, TRUE                                 ;Abortive close if needed
  OCall [xsi].pProtocol::NetComProtocol.Release, xsi    ;Release protocol resources
  invoke DeleteCriticalSection, addr [xsi].CritSect
  ACall xsi.Done
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComConnection.DoReceive
; Purpose:    Perform an asynchronious read operation.
; Arguments:  Arg1: -> IOSockJob.
; Return:     eax = Zero if succeeded, otherwise an error code.

Method NetComConnection.DoReceive, uses xdi xsi, pIOSockJob:PIO_SOCKJOB
  local dResult:DWORD, dFlags:DWORD

  SetObject xsi
;  DbgHex xsi, "NetComConnection.DoReceive"

  mov xdi, pIOSockJob
  invoke EnterCriticalSection, addr [xsi].CritSect      ;Lock for insertion
  lea xcx, [xdi].IO_SOCKJOB.pNextItem                   ;Get address of SDLL_ITEM
  lea xax, [xsi].RcvIOChain                             ;Get address of SDLL_SENTINEL
  SDLL_Append xax, xcx                                  ;Link this IOSockJob to the IO list
  mov dFlags, 0
  lock inc [xsi].dPendingIOJobs                         ;Increment before calling WSARecv 
  lock inc [xsi].dRxInFlight 
  invoke WSARecv, [xsi].hSocket, addr [xdi].IO_SOCKJOB.WSABuf, 1, \
                  addr [xdi].IO_SOCKJOB.dBytesConsumed, addr dFlags, xdi, NULL
  mov dResult, eax
  invoke LeaveCriticalSection, addr [xsi].CritSect
  .if dResult != NO_ERROR                               ;Did read IO complete synchronously?
    invoke WSAGetLastError                              ;No, check if it is a pending state
    .if eax == ERROR_IO_PENDING
      xor eax, eax
    .else
      OCall xsi.OnError, xdi, eax                       ;pIOSockJob
    .endif
  .else
    xor eax, eax
  .endif
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComConnection.DoSend
; Purpose:    Perform an asynchronious write operation.
; Arguments:  Arg1: -> IO_SOCKJOB.
; Return:     eax = Zero if succeeded, otherwise an error code.

Method NetComConnection.DoSend, uses xdi xsi, pIOSockJob:PIO_SOCKJOB
  SetObject xsi
;  DbgHex xsi, "NetComConnection.DoSend"
  mov xdi, pIOSockJob
  lock inc [xsi].dPendingIOJobs                         ;Increment before calling WSASend
  invoke WSASend, [xsi].hSocket, addr [xdi].IO_SOCKJOB.WSABuf, 1, \
                  addr [xdi].IO_SOCKJOB.dBytesConsumed, 0, xdi, NULL
  .if eax != NO_ERROR                                   ;Did read IO complete synchronously?
    invoke WSAGetLastError                              ;No, check if it is a pending state
    .if eax == ERROR_IO_PENDING
      xor eax, eax
    .else
      OCall xsi.OnError, xdi, eax                       ;pIOSockJob
    .endif
  .endif
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComConnection.FlushRcvIOJobs
; Purpose:    Free all gattered IOSockJobs.
; Arguments:  None.
; Return:     Nothing.

Method NetComConnection.FlushRcvIOJobs, uses xbx xdi xsi
  local pItem:POINTER

  SetObject xsi
;  DbgHex xsi, "NetComConnection.FlushRcvIOJobs"

  ;Iterate the RcvIOChain Linked List in reverse order.
  ;Since the socket is closed, no new IOSockJobs are queued
  lea xbx, [xsi].RcvIOChain
  mov xcx, [xsi].pOwner
  mov xdi, [xcx].$Obj(NetComConnectionPool).pIOSockJobPool
  invoke EnterCriticalSection, addr [xsi].CritSect
  ReleaseObject
  mov xsi, [xbx].SDLL_ITEM.pPrevItem                    ;Get the last IOSockJob
  .while xsi != xbx                                     ;Check for end of chain
    m2m pItem, [xsi].SDLL_ITEM.pPrevItem, xax           ;Save prev item in pItem
    sub xsi, IO_HEADER_SIZE                             ;xsi -> IO_SOCKJOB
    OCall xdi::NetComIOSockJobPool.FreeItem, xsi
    mov xsi, pItem                                      ;Move to previos item
  .endw
  SDLL_Init xbx                                         ;Reset the linked list
  SetObject xsi
  invoke LeaveCriticalSection, addr [xsi].CritSect
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComConnection.Init
; Purpose:    Initializes the NetComConnection object.
; Arguments:  Arg1: -> Owner object (NetComConnectionPool).
;             Arg2: -> NetComProtocol or derived object.
; Return:     eax = Zero if succeeded, otherwise an error code.

Method NetComConnection.Init, uses xsi, pOwner:POINTER, pProtocol:POINTER
  local dOption:DWORD

;  DbgText "NetComConnection.Init"
  SetObject xsi
  ?mov xdx, pOwner
  ACall xsi.Init, xdx
  mov [xsi].dFlags, NCC_DISCONNECTED_LOCAL

  invoke InitializeCriticalSection, addr [xsi].CritSect
  m2m [xsi].pProtocol, pProtocol, xax
  lea xax, [xsi].RcvIOChain
  SDLL_Init xax

  OCall pProtocol::NetComProtocol.Allocate, xsi
  .if eax == OBJ_OK
    ;Create a socket with WSA_FLAG_OVERLAPPED flag set! No WSAPROTOCOL_INFO and no Group
    invoke WSASocket, AF_INETX, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED
    mov [xsi].hSocket, xax
    .if xax != INVALID_SOCKET
      ;Set socket options: disable nagle's algorithm for fast reaction time
      mov dOption, 1                                  ;1 means algo disabled
      invoke setsockopt, [xsi].hSocket, IPPROTO_TCP, TCP_NODELAY, addr dOption, sizeof dOption
      DbgCheckSockReturn "NetComConnection.Init - ERROR on SetSockOpt TCP_NODELAY = 1"

      ;Set send buffer size to zero since we provide our own buffers
;      m2z dOption
;      invoke setsockopt, [xsi].hSocket, SOL_SOCKET, SO_SNDBUF, addr dOption, sizeof dOption
;      DbgCheckSockReturn "ERROR on SetSockOpt SO_SNDBUF = 0"
;      invoke setsockopt, [xsi].hSocket, SOL_SOCKET, SO_RCVBUF, addr dOption, sizeof dOption
;      DbgCheckSockReturn "ERROR on SetSockOpt SO_RCVBUF = 0"

      invoke MemZero, addr [xsi].ConnStartTime, sizeof SYSTEMTIME

      xor eax, eax
    .else
      invoke WSAGetLastError
      DbgOnSockError "NetComConnection.Init - Failed to create socket", eax
    .endif
  .endif
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComConnection.OnAccepted
; Purpose:    Associates a newly accepted socket with the IOCP and queues an IOSockJob
;             of the "OPERATION_SOCK_RECV" type.
; Arguments:  Arg1: -> IOSockJob. It contains in the buffer the addresses of both endpoints.
; Return:     Nothing.

Method NetComConnection.OnAccepted, uses xbx xdi xsi, pIOSockJob:PIO_SOCKJOB
  local dRcvLstElpsdTimeSize:DWORD

  SetObject xsi
;  DbgHex xsi, "NetComConnection.OnAccepted"

  mov [xsi].dFlags, 0                                   ;Reset all flags

  ?mov xdx, pIOSockJob
  mov xcx, [xsi].pOwner                                 ;xcx -> NetComConnectionPool
  mov xdi, [xcx].$Obj(NetComConnectionPool).pOwner      ;xdi -> NetComEngine

  mov xbx, [xdx].IO_SOCKJOB.DataBuffer.ACCEPT_DATA.pListener

  ;Updates the accepting socket with the context of the listening socket.
  invoke setsockopt, [xsi].hSocket, SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT, \
                     addr [xbx].LISTENER.hSocket, sizeof HANDLE
  DbgCheckSockReturn "NetComConnection.OnAccepted - Error on SetSockOpt SO_UPDATE_ACCEPT_CONTEXT"

  mov dRcvLstElpsdTimeSize, sizeof DWORD
  invoke getsockopt, [xsi].hSocket, SOL_SOCKET, SO_CONNECT_TIME, \
                     addr [xsi].dRcvLstElpsdTime, addr dRcvLstElpsdTimeSize
  DbgCheckSockReturn "NetComConnection.OnAccepted - ERROR on OnReceived getsockopt SO_CONNECT_TIME"

  ;Get the address of the local endpoint
  mov xcx, pIOSockJob
  mov xdx, [xcx].IO_SOCKJOB.WSABuf.buf
  invoke MemClone, addr [xsi].LocalAddr, addr [xdx].ACCEPT_DATA.LocalAddr, \
                   sizeof NETCOMADDR
;  DbgNetComAddrIPV4 [xsi].LocalAddr, "NetComConnection.OnAccepted - LocalAddr"

  ;Get the address of the remote endpoint
  mov xcx, pIOSockJob
  mov xdx, [xcx].IO_SOCKJOB.WSABuf.buf
  invoke MemClone, addr [xsi].RemoteAddr, \
                   addr [xdx].ACCEPT_DATA.RemoteAddr, \
                   sizeof NETCOMADDR
;  DbgNetComAddrIPV4 [xsi].RemoteAddr, "NetComConnection.OnAccepted - RemoteAddr"

  OCall [xdi].$Obj(NetComEngine).IOSockJobs::NetComIOSockJobPool.FreeItem, pIOSockJob

  ;Notify the NetComConnection's Protocol handler
  OCall [xsi].pProtocol::NetComProtocol.OnAccepted, xsi

  ;Create a new acceptor
  OCall xdi::NetComEngine.NewAcceptor, xbx, [xsi].pProtocol
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComConnection.OnConnected
; Purpose:    A connect operation has finished.
; Arguments:  Arg1: -> IOSockJob.
; Return:     Nothing.

Method NetComConnection.OnConnected, uses  xsi, pIOSockJob:PIO_SOCKJOB
  local dSize:DWORD

  SetObject xsi
;  DbgHex xsi, "NetComConnection.OnConnected"
  mov [xsi].dFlags, 0                                   ;Reset all flags

  mov xcx, [xsi].pOwner
  OCall [xcx].$Obj(NetComConnectionPool).pIOSockJobPool::NetComIOSockJobPool.FreeItem, pIOSockJob
  invoke setsockopt, [xsi].hSocket, SOL_SOCKET, SO_UPDATE_CONNECT_CONTEXT, NULL, 0
;  DbgCheckSockReturn "NetComConnection.OnConnected - ERROR on SetSockOpt SO_UPDATE_CONNECT_CONTEXT"
  invoke GetSystemTime, addr [xsi].ConnStartTime
  mov dSize, sizeof(NETCOMADDR)
  invoke getsockname, [xsi].hSocket, addr [xsi].LocalAddr, addr dSize
;  DbgCheckSockReturn "NetComConnection.OnConnected - getsockname"
;  DbgNetComAddrIPV4 [xsi].LocalAddr, "NetComConnection.OnConnected - LocalAddr"
;  DbgNetComAddrIPV4 [xsi].RemoteAddr, "NetComConnection.OnConnected - RemoteAddr"
  OCall [xsi].pProtocol::NetComProtocol.OnConnected, xsi
  OCall xsi.QueueReceive                                ;Queue a read to recognize a remote
MethodEnd                                               ;  disconnect

; --------------------------------------------------------------------------------------------------
; Method:     NetComConnection.OnError
; Purpose:    An error condition was fired. We have to decide what to do next.
; Arguments:  Arg1: -> IO_SOCKJOB.
;             Arg2: Error.
;             Arg3: Additional Info Text.
;             Arg4: Destination Window name.
; Return:     Nothing.

Method NetComConnection.OnError, uses xbx xdi xsi, pIOSockJob:PIO_SOCKJOB, dError:DWORD
  local dProtocolCommand:DWORD

  SetObject xsi
;  DbgHex xsi, "NetComConnection.OnError"
  mov xbx, pIOSockJob
  mov xdi, [xsi].pOwner                                 ;xdi -> NetComConnectionPool

  movzx eax, [xbx].IO_SOCKJOB.wOperation
  .if eax == OPERATION_SOCK_ACCEPT
    .if dError == ERROR_OPERATION_ABORTED               ;Usual termination IO operation
      OCall [xdi].$Obj(NetComConnectionPool).pIOSockJobPool::NetComIOSockJobPool.FreeItem, xbx
      OCall xsi.QueueDestroy
      OCall xsi.Close, FALSE
    .elseif dError == WSAENOTSOCK
      OCall [xdi].$Obj(NetComConnectionPool).pIOSockJobPool::NetComIOSockJobPool.FreeItem, xbx
      .ifBitClr [xsi].dFlags, NCC_CLOSED
        OCall xsi.QueueDestroy
      .endif
    .else
      DbgOnSockError "NetComConnection.OnError - ACCEPT", dError
      xBitSet [xsi].dFlags, NCE_ACCEPT
      OCall xsi.ErrorSet, dError
      OCall [xsi].pProtocol::NetComProtocol.OnError, xsi, xbx, dError
      mov dProtocolCommand, eax
      ;Freeing of this IOJob must be done before QueueDestroy
      OCall [xdi].$Obj(NetComConnectionPool).pIOSockJobPool::NetComIOSockJobPool.FreeItem, xbx
      .if dProtocolCommand == PROT_CMD_REJECT_CONNECTION
        OCall xsi.QueueDestroy
        OCall xsi.Close, FALSE
      .endif
    .endif

  .elseif eax == OPERATION_SOCK_CONNECT
    .if dError == ERROR_OPERATION_ABORTED               ;Usual termination IO operation
      DbgOnSockError "NetComConnection.OnError - CONNECT OPERATION ABORTED", dError
      xBitClr [xsi].dFlags, NCE_CONNECT
      OCall xsi.ErrorSet, dError
      OCall [xsi].pProtocol::NetComProtocol.OnError, xsi, xbx, dError
      mov dProtocolCommand, eax
      .if dProtocolCommand == PROT_CMD_DESTROY
        OCall xsi.QueueDestroy
        OCall xsi.Close, FALSE
      .endif
    .elseif dError == WSAECONNREFUSED
      DbgOnSockError "NetComConnection.OnError - CONNECT OPERATION REFUSED", dError
      xBitClr [xsi].dFlags, NCE_CONNECT
      OCall xsi.ErrorSet, dError
      OCall [xsi].pProtocol::NetComProtocol.OnError, xsi, xbx, dError
      mov dProtocolCommand, eax
      .if dProtocolCommand == PROT_CMD_DESTROY
        OCall xsi.QueueDestroy
        OCall xsi.Close, FALSE
      .endif
    .endif
    OCall [xdi].$Obj(NetComConnectionPool).pIOSockJobPool::NetComIOSockJobPool.FreeItem, xbx

  .elseif eax == OPERATION_SOCK_SEND
    .if dError != ERROR_OPERATION_ABORTED               ;Usual termination IO operation
      .ifBitClr [xsi].dFlags, NCC_DESTROY_QUEUED
        DbgOnSockError "NetComConnection.OnError - Send", dError
        xBitSet [xsi].dFlags, NCE_SEND
        OCall xsi.ErrorSet, dError
        OCall [xsi].pProtocol::NetComProtocol.OnError, xsi, xbx, dError
        .if dProtocolCommand == PROT_CMD_DISCONNECT
          DbgOnSockError "NetComConnection.OnError - READ | Disconnect", dError
          OCall xsi.Disconnect, SD_BOTH
        .elseif dProtocolCommand == PROT_CMD_CLOSE
;          DbgOnSockError "NetComConnection.OnError - READ | Close", dError
          OCall xsi.Close, TRUE
        .elseif dProtocolCommand == PROT_CMD_DESTROY
          DbgOnSockError "NetComConnection.OnError - READ | Free", dError
          OCall xsi.QueueDestroy
          OCall xsi.Close, TRUE
        .else
          DbgOnSockError "NetComConnection.OnError - READ | Unknown protocol command", dError
          DbgHex dProtocolCommand, "NetComConnection.OnError"
        .endif
      .endif
    .endif
    OCall [xdi].$Obj(NetComConnectionPool).pIOSockJobPool::NetComIOSockJobPool.FreeItem, xbx

  .elseif eax == OPERATION_SOCK_RECV
    .if dError != ERROR_OPERATION_ABORTED               ;Usual termination IO operation
                                                        ;Don't remove the IOJob. It's RcvIOChain chained
      OCall [xsi].pProtocol::NetComProtocol.OnError, xsi, xbx, dError
      mov dProtocolCommand, eax

      .ifBitClr [xsi].dFlags, NCC_DESTROY_QUEUED
        xBitSet [xsi].dFlags, NCE_RECEIVE
        OCall xsi.ErrorSet, dError
        .if dProtocolCommand == PROT_CMD_DISCONNECT
          DbgOnSockError "NetComConnection.OnError - READ | Disconnect", dError
          OCall xsi.Disconnect, SD_BOTH
        .elseif dProtocolCommand == PROT_CMD_CLOSE
;          DbgOnSockError "NetComConnection.OnError - READ | Close", dError
          OCall xsi.Close, TRUE
        .elseif dProtocolCommand == PROT_CMD_DESTROY
          DbgOnSockError "NetComConnection.OnError - READ | Free", dError
          OCall xsi.QueueDestroy
          OCall xsi.Close, TRUE
        .else
          DbgOnSockError "NetComConnection.OnError - READ | Unknown protocol command", dError
          DbgHex dProtocolCommand, "NetComConnection.OnError"
        .endif
      .endif
    .endif
    OCall [xdi].$Obj(NetComConnectionPool).pIOSockJobPool::NetComIOSockJobPool.FreeItem, xbx

  .else
    DbgOnSockError "NetComConnection.OnError - Unknown operation", dError
    DbgHex [xbx].IO_SOCKJOB.wOperation, "NetComConnection.OnError"
    OCall [xdi].$Obj(NetComConnectionPool).pIOSockJobPool::NetComIOSockJobPool.FreeItem, xbx

  .endif
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComConnection.OnReceived
; Purpose:    A read operation has finished.
; Arguments:  Arg1: -> IO_SOCKJOB.
; Return:     eax = Zero if succeeded, otherwise an error code.

Method NetComConnection.OnReceived, uses xbx xdi xsi, pIOSockJob:PIO_SOCKJOB
  local dConsumed:DWORD, dRcvLstElpsdTimeSize:DWORD

  SetObject xsi
;  DbgHex xsi, "NetComConnection.OnReceived"
  lock dec [xsi].dRxInFlight
  ?mov xdx, pIOSockJob
  mov xbx, [xsi].pOwner

  xBitSet [xdx].IO_SOCKJOB.wFlags, IOF_JOB_LINKED
  ;Check for special case of remote socket closure (remote sent a FIN) - end of stream
  .if [xdx].IO_SOCKJOB.dBytesConsumed == 0              ;Graceful remote shutdown send
    ;There is no other possibility to get a zero length payload => No need to pass it
    ;to any protocol handler
;    DbgText "NetComConnection.OnReceived - dBytesConsumed = 0"
    BitSet [xsi].dFlags, NCC_SHUTDOWN_TX_REMOTE       ;Remote shutdown send
    .ifBitClr [xsi].dFlags, NCC_CLOSED
      OCall xsi.Disconnect, SD_RECEIVE                  ;Local shutdown receive
    .endif
    ;Free this last packet
    OCall [xbx].$Obj(NetComConnectionPool).pIOSockJobPool::NetComIOSockJobPool.FreeItem, pIOSockJob

  .else
    mov xdx, pIOSockJob
    ;We queue a new read for the one we recieve here
    OCall [xbx].$Obj(NetComConnectionPool).pIOSockJobPool::NetComIOSockJobPool.NewItem, \
                                                                               OPERATION_SOCK_RECV
    .if xax != NULL
      OCall xsi.DoReceive, xax                          ;Increments pending IOJobs
    .else
      DbgHex xsi, "NetComConnection.OnReceived - DoReceive failed"
    .endif

    ;Return the number of seconds a socket has been connected.
    mov dRcvLstElpsdTimeSize, sizeof DWORD
    invoke getsockopt, [xsi].hSocket, SOL_SOCKET, SO_CONNECT_TIME, \
                       addr [xsi].dRcvLstElpsdTime, addr dRcvLstElpsdTimeSize
    DbgCheckSockReturn "ERROR on OnReceived getsockopt SO_CONNECT_TIME"

    OCall [xsi].pProtocol::NetComProtocol.IsDataComplete?, xsi, pIOSockJob
    .if eax == ERROR_BAD_PROTOCOL || eax == ERROR_USER_QUIT
      OCall xsi.Disconnect, SD_BOTH
      OCall [xbx].$Obj(NetComConnectionPool).pIOSockJobPool::NetComIOSockJobPool.FreeItem, pIOSockJob
      OCall xsi.QueueDestroy
    .elseif eax != 0
      OCall [xsi].pProtocol::NetComProtocol.ProcessData, xsi, eax   ;Return value is the #of BYTES that can be disposed
      .if eax != 0                                        ;eax = byte count to free from IO_SOCKJOBs
        ;eax = #bytes consumed, which should be removed.
        ;Note this value could be larger than one IOSockJob buffer, meaning that it represents
        ;several IOSockJobs. Also note that the total #bytes buffered could be larger than the
        ;#bytes consumed meaning the last IOSockJob will contain some data that is not part of
        ;the complete receive and must remain buffered!
        mov dConsumed, eax
        lea xdi, [xsi].RcvIOChain                       ;Sentinel
        mov xbx, [xdi].SDLL_SENTINEL.pFirstItem         ;Get first item
        .while xbx != xdi && dConsumed != 0
;          DbgStr [xbx - IO_HEADER_SIZE].IO_SOCKJOB.WSABuf.buf
          mov edx, [xbx - IO_HEADER_SIZE].IO_SOCKJOB.dBytesConsumed
          .if edx <= dConsumed
            sub dConsumed, edx
            mov xcx, [xsi].pOwner
            lea xax, [xbx - IO_HEADER_SIZE]             ;xax -> IOSockJob
            mov pIOSockJob, xax
            mov xbx, [xbx].SDLL_ITEM.pNextItem
            OCall [xcx].$Obj(NetComConnectionPool).pIOSockJobPool::NetComIOSockJobPool.FreeItem,\
                                                                                      pIOSockJob
            .break .if dConsumed == 0
          .else
            ;This is the last IOSockJob to be purged. We will be leaving some data in the buffer,
            ;so we'll need to move the buffer POINTER to the unconsumed data.
            mov ecx, dConsumed
            add [xbx - IO_HEADER_SIZE].IO_SOCKJOB.WSABuf.buf, xcx
            sub [xbx - IO_HEADER_SIZE].IO_SOCKJOB.dBytesConsumed, ecx
            .break
          .endif
        .endw
        mov [xdi].SDLL_SENTINEL.pFirstItem, xbx
        mov [xbx].SDLL_ITEM.pPrevItem, xdi
      .endif
    .endif
  .endif
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComConnection.OnSent
; Purpose:    A write operation has finished.
; Arguments:  Arg1: -> IO_SOCKJOB.
; Return:     Nothing.

Method NetComConnection.OnSent,, pIOSockJob:PIO_SOCKJOB
  SetObject xcx
;  DbgHex xcx, "NetComConnection.OnSent"

  mov xdx, pIOSockJob
  mov eax, [xdx].IO_SOCKJOB.dBytesConsumed
  lock sub [xcx].dTxQueuedBytes, eax

  ;If below Low-WM => clear block
  mov eax, [xcx].dTxQueuedBytes
  .if eax < [xcx].dTxLowWM
    BitClr [xcx].dFlags, NCC_TX_PAUSED
  .endif

  ;Toss the completed IOSockJob back in the IOJobPool
  mov xax, [xcx].pOwner
  OCall [xax].$Obj(NetComConnectionPool).pIOSockJobPool::NetComIOSockJobPool.FreeItem, xdx
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComConnection.QueueAccept
; Purpose:    Queues an accept IO_SOCKJOB.
; Arguments:  Arg1: -> LISTENER.
; Return:     eax = Zero if succeeded, otherwise an error code.

Method NetComConnection.QueueAccept, uses xdi xsi, pListener:PLISTENER
  local dRetValue:DWORD, dBytesRecieved:DWORD

  SetObject xsi
;  DbgHex xsi, "NetComConnection.QueueAccept"
  mov dRetValue, 0

  ;Allocate an IOSockJob to represent the accept IO operation
  mov xcx, [xsi].pOwner
  OCall [xcx].$Obj(NetComConnectionPool).pIOSockJobPool::NetComIOSockJobPool.NewItem, \
                                                          OPERATION_SOCK_ACCEPT
  ;DbgHex xax, "NetComConnection.QueueAccept - Acceptor IOSockJob"
  .if xax != NULL
    mov xdi, xax
    mrm [xdi].IO_SOCKJOB.DataBuffer.ACCEPT_DATA.pListener, pListener, xcx   ;xcx -> LISTENER
    mov [xdi].IO_SOCKJOB.DataBuffer.ACCEPT_DATA.pConnection, xsi

    lock inc [xsi].dPendingIOJobs                           ;Increment before calling AcceptEx
    ;if ReceiveDataLength = 0, AcceptEx completes as soon as a connection arrives,
    ;without waiting for any data. Local and remote addresses are written into the buffer
    invoke AcceptEx, [xcx].LISTENER.hSocket, [xsi].hSocket, [xdi].IO_SOCKJOB.WSABuf.buf, 0, \
                     sizeof ACCEPT_DATA.LocalAddr, \
                     sizeof ACCEPT_DATA.RemoteAddr, \
                     addr dBytesRecieved, xdi
    .if eax == FALSE
      invoke WSAGetLastError
      mov dRetValue, eax
      .if eax == ERROR_IO_PENDING                           ;Accept is pending, which is normal
;        DbgHex xsi, "NetComConnection.QueueAccept - Connection accept pending"
      .elseif eax == WSAECONNRESET                          ;An incoming connection was indicated,
        OCall xsi.OnError, xdi, eax                         ;but was subsequently terminated by the
        ExitMethod                                          ;remote peer prior to accepting the call
      .else
        OCall xsi.OnError, xdi, eax
        ExitMethod
      .endif
    .else
;      DbgHex xsi, "NetComConnection.QueueAccept - Connection accepted immediately"
    .endif
  .else
    OCall xsi.ErrorReport, NULL, NCCN_OUT_OF_MEMORY
    mov dRetValue, WSA_NOT_ENOUGH_MEMORY
  .endif

  mov eax, dRetValue
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComConnection.QueueDestroy
; Purpose:    Mark a NetCom connection to destroy.
; Arguments:  None.
; Return:     Nothing.

Method NetComConnection.QueueDestroy
  SetObject xcx
;  DbgHex xcx, "NetComConnection.QueueDestroy"
  xBitSet [xcx].dFlags, NCC_DESTROY_QUEUED
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComConnection.QueueConnect
; Purpose:    Queue a connect IO_SOCKJOB.
; Arguments:  Arg1: -> Remote address.
;             Arg2: -> Local address. If NULL, not binding is performed.
; Return:     eax = Zero if succeeded, otherwise an error code.

Method NetComConnection.QueueConnect, uses xdi xsi, pRemoteAddr:PNETCOMADDR, pLocalAddr:PNETCOMADDR
  local dOption:DWORD;, dSize:DWORD

  SetObject xsi
;  DbgHex xsi, "NetComConnection.QueueConnect"

  ;Here we can change the returning port
  mov dOption, 1
  invoke setsockopt, [xsi].hSocket, SOL_SOCKET, SO_REUSEADDR, addr dOption, sizeof dOption
;  DbgCheckSockReturn "NetComConnection.QueueConnect- ERROR on SetSockOpt SO_REUSEADDR"

  invoke MemClone, addr [xsi].RemoteAddr, pRemoteAddr, sizeof NETCOMADDR

  ;Associate a local address with the socket
  .if pLocalAddr != NULL
    invoke MemClone, addr [xsi].LocalAddr, pLocalAddr, sizeof NETCOMADDR
    invoke bind, [xsi].hSocket, pLocalAddr, sizeof NETCOMADDR
    .if eax != 0
;      DbgSockError "NetComConnection.QueueConnect - BIND result"
      ExitMethod
    .endif
  .endif

;  DbgNetComAddrIPV4 [xsi].RemoteAddr, "NetComConnection.QueueConnect - RemoteAddr"
;  DbgNetComAddrIPV4 [xsi].LocalAddr, "NetComConnection.QueueConnect - LocalAddr"

  mov xcx, [xsi].pOwner                               ;xcx -> NetComConnectionPool
  OCall [xcx].$Obj(NetComConnectionPool).pIOSockJobPool::NetComIOSockJobPool.NewItem, \
                                                                            OPERATION_SOCK_CONNECT
  .if xax == NULL
    OCall xsi.ErrorReport, NULL, NCCN_OUT_OF_MEMORY
    mov eax, -1
    ExitMethod
  .endif

  mov xdi, xax
  m2z [xdi].IO_SOCKJOB.WSABuf.len                 ;Size MUST be zero
  lock inc [xsi].dPendingIOJobs                   ;Increment before calling ConnectEx
  invoke PTO_CONNECTEX ptr pConnectEx, [xsi].hSocket, pRemoteAddr, sizeof NETCOMADDR, \
                                       NULL, 0, NULL, xdi
  .if eax == FALSE
    invoke WSAGetLastError                        ;Connectiopn pending
    .if eax == ERROR_IO_PENDING
;      DbgHex xsi, "NetComConnection.QueueConnect - Connection pending"
      xor eax, eax
      ExitMethod
    .elseif eax != NO_ERROR                       ;NO_ERROR => completed in the meantime
      DbgSockError "NetComConnection.QueueConnect - Error while connecting", eax
;      DbgHex xsi, "NetComConnection.QueueConnect - Connection with error"
      OCall xsi.OnError, xdi, eax
      ExitMethod
    .endif
  .endif
  ;Connection completed
  DbgText "NetComConnection.QueueConnect - Connection completed immediately"
  xor eax, eax
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComConnection.QueueReceive
; Purpose:    Queue a read IO_SOCKJOB.
; Arguments:  None.
; Return:     eax = Zero if succeeded, otherwise an error code.

Method NetComConnection.QueueReceive, uses xsi
  SetObject xsi
;  DbgHex xsi, "NetComConnection.QueueReceive"
  mov xcx, [xsi].pOwner
  OCall [xcx].$Obj(NetComConnectionPool).pIOSockJobPool::NetComIOSockJobPool.NewItem, \
                                                                             OPERATION_SOCK_RECV
  .if xax != NULL
    OCall xsi.DoReceive, xax                            ;dRxInFlight is incremented inside DoReceive
  .endif
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComConnection.QueueSend
; Purpose:    Copy the information pointed to by pData to the send buffers and queue a
;             write operation on each one.
; Arguments:  Arg1: -> Data buffer.
;             Arg2: Data size.
; Return:     eax = Data size not queued. Zero means all was sent.

Method NetComConnection.QueueSend, uses xdi xsi, pData:POINTER, dSize:DWORD
  local dBufferSize:DWORD, pItem:POINTER, dAvail:DWORD

  SetObject xsi
;  DbgHex xsi, "NetComConnection.QueueSend"
  mov eax, dSize
  mov edx, [xsi].dTxHighWM
  sub edx, [xsi].dTxQueuedBytes
  .if SIGN? || ZERO?
    BitSet [xsi].dFlags, NCC_TX_PAUSED
    ExitMethod                                        ;eax = dSize                         
  .endif
  mov edi, eax
  cmp edi, edx
  cmovg edi, edx
  
  mov xcx, [xsi].pOwner                               ;xcx -> NetComConnectionPool
  mov xdx, [xcx].$Obj(NetComConnectionPool).pIOSockJobPool  ;xdx -> NetComIOJobPool
  m2m dBufferSize, [xdx].$Obj(NetComIOSockJobPool).dBufferSize, eax

  .while edi != 0
    mov xcx, [xsi].pOwner                             ;xcx -> NetComConnectionPool
    OCall [xcx].$Obj(NetComConnectionPool).pIOSockJobPool::NetComIOSockJobPool.NewItem, \
                                                                             OPERATION_SOCK_SEND
    .if xax != NULL
      mov pItem, xax
      .if dBufferSize < edi
        ;Send a full buffer and cycle again
        m2m [xax].IO_SOCKJOB.WSABuf.len, dBufferSize, edx
        invoke MemClone, [xax].IO_SOCKJOB.WSABuf.buf, pData, dBufferSize
        OCall xsi.DoSend, pItem
        mov edx, dBufferSize
        sub edx, eax 
        lock add [xsi].dTxQueuedBytes, edx
        sub edi, edx
        .break .if eax != 0
        add pData, xdx
      .else
        ;Send a partially full buffer and break
        mov [xax].IO_SOCKJOB.WSABuf.len, edi
        invoke MemClone, [xax].IO_SOCKJOB.WSABuf.buf, pData, edi
        OCall xsi.DoSend, pItem
        mov edx, edi
        sub edx, eax 
        lock add [xsi].dTxQueuedBytes, edx
        sub edi, edx
        .break
      .endif
    .else
      OCall xsi.ErrorReport, NULL, NCCN_OUT_OF_MEMORY
      .break
    .endif
  .endw
  mov eax, edi
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComConnection.TryQueueReceive
; Purpose:    Tries to resume the receiving IOJobs.
; Arguments:  None.
; Return:     Nothing.

Method NetComConnection.TryQueueReceive, uses xsi
  SetObject xsi
  .ifBitClr [xsi].dFlags, NCC_RX_PAUSED
    .if [xsi].dRxInFlight == 0
      OCall xsi.QueueReceive
    .endif
  .endif
MethodEnd

endif

; ==================================================================================================
; Title:      NetComConnectionPool.inc
; Author:     G. Friedrich
; Version:    C.1.0
; Purpose:    ObjAsm support of NetComConnectionPool objects.
; Notes:      Version C.1.0, October 2017
;               - First release.
; ==================================================================================================


.code

if IMPLEMENT

; ==================================================================================================
;    NetComConnectionPool implementation
; ==================================================================================================

; --------------------------------------------------------------------------------------------------
; Method:     NetComConnectionPool.FreeItem
; Purpose:    Finalize the NetComConnectionPool object.
; Arguments:  Arg1: -> NetComConnection to free.
; Return:     Nothing.

Method NetComConnectionPool.FreeItem, uses xsi, pConnection:$ObjPtr(NetComConnection)
;  DbgHex pConnection, "NetComConnectionPool.FreeItem"
  SetObject xsi
  LockObjectAccess [xsi].$Obj(NetComConnectionPool)
;  DbgHex pConnection, "Free", "NetComConnectionPool"
  lock dec [xsi].dCount
  mov xax, pConnection
  lea xdx, [xax].$Obj(NetComConnection).ChainItem
  SDLL_Remove xdx, xax, xcx                             ;Remove connection from the chain
  ACall xsi.FreeItem, pConnection                       ;Return it to the DataPool
  UnlockObjectAccess [xsi].$Obj(NetComConnectionPool)
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComConnectionPool.Init
; Purpose:    Initialize the NetComConnectionPool object.
; Arguments:  Arg1: -> Owner.
;             Arg2: Desired maximal capacity.
;             Arg3: -> NetComIOSockJobPool.
; Return:     eax = Zero if succeeded, otherwise an error code.

Method NetComConnectionPool.Init,, pOwner:POINTER, dMaxClients:DWORD, pIOSockJobPool:POINTER
  SetObject xcx
  m2m [xcx].pIOSockJobPool, pIOSockJobPool, xax
  ACall xcx.Init, pOwner, sizeof($Obj(NetComConnection)), dMaxClients, 1
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComConnectionPool.NewItem
; Purpose:    Create a new NetComConnection.
; Arguments:  None.
; Return:     xax -> NetComConnection or NULL if failed.

Method NetComConnectionPool.NewItem, uses xbx xsi
  SetObject xsi
  LockObjectAccess [xsi].$Obj(NetComConnectionPool)
  ACall xsi.NewItem                                     ;Get a new connection from the pool
  .if xax != NULL
    lock inc [xsi].dCount
    mov xbx, xax
    New xbx::NetComConnection
    lea xax, [xbx].$Obj(NetComConnection).ChainItem
    mov xdx, [xsi].pOwner
    lea xcx, [xdx].$Obj(NetComEngine).ConnectionChain   ;Get the address of the connection chain
    SDLL_InsertFirst xcx, xax, xdx                      ;Insert this connection in the chain
    UnlockObjectAccess [xsi].$Obj(NetComConnectionPool)
    mov xax, xbx
;    DbgHex xax, "New", "NetComConnectionPool"
  .else
    UnlockObjectAccess [xsi].$Obj(NetComConnectionPool)
    OCall xsi.ErrorReport, NULL, NCCP_OUT_OF_MEMORY
    xor eax, eax
  .endif
MethodEnd

endif

; ==================================================================================================
; Title:      NetComIOSockJobPool.inc
; Author:     G. Friedrich
; Version:    C.1.0
; Purpose:    ObjAsm support of NetComIOSockJobPool objects.
; Notes:      Version C.1.0, October 2017
;               - First release.
; ==================================================================================================


.code

if IMPLEMENT

; ==================================================================================================
;    NetComIOSockJobPool implementation
; ==================================================================================================

; --------------------------------------------------------------------------------------------------
; Method:     NetComIOSockJobPool.FreeItem
; Purpose:    Release memory of a specified IO_SOCKJOB.
; Arguments:  Arg1: -> IO_SOCKJOB.
; Return:     Nothing.

Method NetComIOSockJobPool.FreeItem, uses xsi, pIOSockJob:PIO_SOCKJOB
  SetObject xsi
  LockObjectAccess [xsi].$Obj(NetComIOSockJobPool)
  dec [xsi].dCount
  ACall xsi.FreeItem, pIOSockJob                        ;Return it to the DataPool
  UnlockObjectAccess [xsi].$Obj(NetComIOSockJobPool)
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComIOSockJobPool.Init
; Purpose:    Initialize the NetComIOSockJobPool object.
; Arguments:  Arg1: -> Owner object.
;             Arg2: Initial allocated NetComIOJobs.
;             Arg3: Buffer size of each NetComIOJob. Usually MSS_ETHERNET_IPVX (MTU - Header size).
; Return:     eax = Zero if succeeded, otherwise an error code.

Method NetComIOSockJobPool.Init,, pOwner:POINTER, dInitJobCount:DWORD, dBufferSize:DWORD
  SetObject xcx
  mrm [xcx].dBufferSize, dBufferSize, eax
  add eax, sizeof(IO_SOCKJOB)                           ;Add the header size to the payload size
  ACall xcx.Init, pOwner, eax, dInitJobCount, 1         ;We need an alignment of 1
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComIOSockJobPool.NewItem
; Purpose:    Allocate a new IO_SOCKJOB from DataPool.
; Arguments:  Arg1: Operation type.
; Return:     eax -> New IO_SOCKJOB or NULL if failed.

Method NetComIOSockJobPool.NewItem, uses xsi, wOperation:WORD
  SetObject xsi
  LockObjectAccess [xsi].$Obj(NetComIOSockJobPool)
  ACall xsi.NewItem
  .if xax != NULL
    inc [xsi].dCount
    UnlockObjectAccess [xsi].$Obj(NetComIOSockJobPool)
    OCall xsi.ResetIOJob, xax, wOperation
  .else
    UnlockObjectAccess [xsi].$Obj(NetComIOSockJobPool)
    OCall xsi.ErrorReport, NULL, NCJP_OUT_OF_MEMORY
    xor eax, eax
  .endif
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComIOSockJobPool.Reset
; Purpose:    Restores initial state, releasing the complete allocated memory.
; Arguments:  None.
; Return:     Nothing.

Method NetComIOSockJobPool.Reset, uses xsi
  SetObject xsi
  ACall xsi.Reset
  mov [xsi].dCount, 0
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComIOSockJobPool.ResetIOJob
; Purpose:    Reset an IO_SOCKJOB.
; Arguments:  Arg1: -> IO_SOCKJOB.
;             Arg2: Operation type.
; Return:     eax -> IO_SOCKJOB.

Method NetComIOSockJobPool.ResetIOJob,, pIOSockJob:PIO_SOCKJOB, wOperation:WORD
  SetObject xcx
  ?mov xdx, pIOSockJob
  mov xax, xdx
  add xdx, sizeof IO_SOCKJOB
  mov [xax].IO_SOCKJOB.WSABuf.buf, xdx
  m2m [xax].IO_SOCKJOB.WSABuf.len, [xcx].dBufferSize, edx
  xor ecx, ecx
  m2m [xax].IO_SOCKJOB.wOperation, wOperation, dx
  mov [xax].IO_SOCKJOB.pNextItem, xcx
  mov [xax].IO_SOCKJOB.pPrevItem, xcx
  mov [xax].IO_SOCKJOB.dBytesConsumed, ecx
  mov [xax].IO_SOCKJOB.wFlags, cx
  mov [xax].IO_SOCKJOB.Ovl.Internal, xcx
  mov [xax].IO_SOCKJOB.Ovl.InternalHigh, xcx
  mov [xax].IO_SOCKJOB.Ovl.Offset_, ecx
  mov [xax].IO_SOCKJOB.Ovl.OffsetHigh, ecx
  mov [xax].IO_SOCKJOB.Ovl.hEvent, xcx
MethodEnd

endif

; ==================================================================================================
; Title:      NetComProtocol.inc
; Author:     G. Friedrich
; Version:    C.1.0
; Purpose:    ObjAsm support of NetComProtocol objects.
;             Version C.1.0, October 2017
;               - First release.
; ==================================================================================================


.code

if IMPLEMENT

; ==================================================================================================
;    NetComProtocol implementation
; ==================================================================================================

; --------------------------------------------------------------------------------------------------
; Method:     NetComProtocol.Allocate
; Purpose:    Allocate a memory chunk for management data on a per Connection basis.
;             Additional related resources can be reserved here. The POINTER to the allocated memory
;             must be stored in pData member of NetComConnection.
; Arguments:  Arg1: -> NetComConnection.
; Return:     eax = Zero if succeeded, otherwise an error code.

Method NetComProtocol.Allocate,, pConnection:$ObjPtr(NetComConnection)
;  DbgHex pConnection, "NetComProtocol.Allocate", "&PROTOCOL_WND_NAME"
  xor eax, eax
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComProtocol.AddToBlackList
; Purpose:    Add an address to the BlackList.
; Arguments:  Arg1: -> NETCOMADDR.
;             Arg2: Flags.
; Return:     eax -> New ListEntry.

Method NetComProtocol.AddToBlackList,, pAddr:PNETCOMADDR
  SetObject xcx
  ?mov xdx, pAddr
  OCall [xcx].BlackList::NetComAddrCollection.Insert, xdx
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComProtocol.Done
; Purpose:    Finalize this object.
; Arguments:  None.
; Return:     Nothing.

Method NetComProtocol.Done, uses xsi
  SetObject xsi
;  invoke StrDispose, [xsi].pLocalHostSrvName
  OCall [xsi].BlackList::NetComAddrCollection.Done
  ACall xsi.Done
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComProtocol.Init
; Purpose:    Initialize this object.
; Arguments:  Arg1: -> Owner object.
;             Arg2: -> String representing the service or the port number as a string.
; Return:     eax = Zero if succeeded, otherwise an error code.

Method NetComProtocol.Init, uses xsi, pOwner:POINTER;, pServiceName:PSTRING
  SetObject xsi
  ?mov xdx, pOwner
  ACall xsi.Init, xdx
;  mov [xsi].pLocalHostSrvName, $invoke(StrNew, pServiceName)
  OCall [xsi].BlackList::NetComAddrCollection.Init, xsi, 10, 10, COL_MAX_CAPACITY
  xor eax, eax
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComProtocol.IsDataComplete?
; Purpose:    A NetComConnection object will call this method to determine if we have received at
;             least one complete packet, given the rules of your Protocol. This is where your
;             derived Object examines the received data looking to find a valid Delimiter and doing
;             protocol enforcement.
; Arguments:  Arg1: -> NetComConnection.
;             Arg2: -> IO_SOCkJOB
; Return:     eax = ERROR_BAD_PROTOCOL - The buffer content is not following our protocol -
;                                        the client will get booted for this offence.
;                   ERROR_USER_QUIT    - The user sent a nice QUIT message using our protocol -
;                                        the client will get booted for this.
;                   Positive INT32     - This many bytes are valid buffer information.
;                   Zero               - We need more data.
; Note:       Zero length packets are NOT passed from the connection to the protocol.

Method NetComProtocol.IsDataComplete?,, pConnection:$ObjPtr(NetComConnection), \
                                        pIOSockJob:PIO_SOCKJOB
;  DbgHex pConnection, "NetComProtocol.IsDataComplete?", "&PROTOCOL_WND_NAME"
  xor eax, eax
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComProtocol.IsBlackListed?
; Purpose:    Check if an address is in a List (DataCollection).
; Arguments:  Arg1: -> NETCOMADDR to be checked for.
; Return:     eax = Found condition (TRUE/FALSE).
;             ecx = Index in the range [0..Count]. If the ListEntry is not found, ecx is set to the
;                   index where the ListEntry would be placed if inserted.
; ToDo:       Add CIDR matching.

Method NetComProtocol.IsBlackListed?,, pAddr:PNETCOMADDR
  SetObject xcx
  ?mov xdx, pAddr
  OCall [xcx].BlackList::NetComAddrCollection.Search, xdx
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComProtocol.OnAccepted
; Purpose:    An inbound connection 'accept' has completed.
; Arguments:  Arg1: -> NetComConnection.
; Return:     eax = Command (PROT_CMD_ACCEPT_CONNECTION or PROT_CMD_REJECT_CONNECTION).

Method NetComProtocol.OnAccepted,, pConnection:$ObjPtr(NetComConnection)
;  DbgHex pConnection, "NetComProtocol.OnAccepted", "&PROTOCOL_WND_NAME"
  mov eax, PROT_CMD_ACCEPT_CONNECTION
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComProtocol.OnClosed
; Purpose:    A connection has, for whatever reason, been terminated.
;             You can override this, perhaps to release extra per connection resources.
; Arguments:  Arg1: -> NetComConnection.
; Return:     Nothing.

Method NetComProtocol.OnClosed,, pConnection:$ObjPtr(NetComConnection)
;  DbgHex pConnection, "NetComProtocol.OnClosed", "&PROTOCOL_WND_NAME"
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComProtocol.OnConnected
; Purpose:    An outbound connection attempt has completed.
; Arguments:  Arg1: -> NetComConnection.
; Return:     Nothing.

Method NetComProtocol.OnConnected,, pConnection:$ObjPtr(NetComConnection)
;  DbgHex pConnection, "NetComProtocol.OnConnected", "&PROTOCOL_WND_NAME"
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComProtocol.OnDisconnected
; Purpose:    An established connection has been disconnected.
; Arguments:  Arg1: -> NetComConnection.
;             Arg2: Disconnect direction = SD_SEND/SD_RECEIVE/SD_BOTH
; Return:     Nothing.

Method NetComProtocol.OnDisconnected,, pConnection:$ObjPtr(NetComConnection), dDirection:DWORD
;  DbgHex pConnection, "NetComProtocol.OnDisconnected", "&PROTOCOL_WND_NAME"
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComProtocol.OnError
; Purpose:    Error notification handler.
; Arguments:  Arg1: -> NetComConnection.
;             Arg2: -> IOSockJob.
;             Arg3: Error code.
; Return:     eax = Command (PROT_CMD_REJECT_CONNECTION, PROT_CMD_CLOSE, ...)

Method NetComProtocol.OnError,, pConnection:$ObjPtr(NetComConnection), pIOSockJob:PIO_SOCKJOB, \
                                dError:DWORD
;  DbgHex pConnection, "NetComProtocol.OnError", "&PROTOCOL_WND_NAME"
;  DbgDec dError, "NetComProtocol.OnError", "&PROTOCOL_WND_NAME"
  mov xcx, pIOSockJob
  .if xcx == NULL
    xor eax, eax
    ExitMethod
  .endif

  movzx eax, [xcx].IO_SOCKJOB.wOperation
  .if eax == OPERATION_SOCK_ACCEPT
    mov eax, PROT_CMD_DESTROY
  .elseif eax == OPERATION_SOCK_CONNECT
    mov eax, PROT_CMD_DESTROY
  .elseif eax == OPERATION_SOCK_SEND
    mov eax, PROT_CMD_DESTROY
  .elseif eax == OPERATION_SOCK_RECV
    mov eax, PROT_CMD_DESTROY
  .else
    mov eax, PROT_CMD_DESTROY
  .endif
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComProtocol.OnTimeouted
; Purpose:    A connection timeout occurs.
; Arguments:  Arg1: -> NetComConnection.
; Return:     eax = PROT_CMD_CONTINUE or PROT_CMD_DISCONNECT.

Method NetComProtocol.OnTimeouted,, pConnection:$ObjPtr(NetComConnection)
;  DbgHex pConnection, "NetComProtocol.OnTimeouted", "&PROTOCOL_WND_NAME"
  mov eax, PROT_CMD_DISCONNECT
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComProtocol.ProcessData
; Purpose:    A client has finished sending us data, now we have to do something with that data.
; Arguments:  Arg1: -> NetComConnection.
;             Arg2: Delimiter index found in NetComProtocol.IsDataComplete?.
; Return:     eax = Number of processed bytes.

Method NetComProtocol.ProcessData,, pConnection:$ObjPtr(NetComConnection), dDelimiterIndex:DWORD
;  DbgHex pConnection, "NetComProtocol.ProcessData", "&PROTOCOL_WND_NAME"
  mov eax, dDelimiterIndex
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComProtocol.Release
; Purpose:    Release the memory chunk allocated with Allocate. Additional resources must be freed
;             here.
; Arguments:  Arg1: -> NetComConnection.
; Return:     Nothing.

Method NetComProtocol.Release,, pConnection:$ObjPtr(NetComConnection)
;  DbgHex pConnection, "NetComProtocol.Release", "&PROTOCOL_WND_NAME"
MethodEnd

endif

; ==================================================================================================
; Title:      NetComAddrCollection.inc
; Author:     G. Friedrich
; Version:    C.1.0
; Purpose:    ObjAsm support of NetComAddrCollection objects.
; Notes:      Version C.1.0, October 2017
;               - First release.
; ==================================================================================================


.code

if IMPLEMENT

; ==================================================================================================
;    NetComAddrCollection implementation
; ==================================================================================================

; --------------------------------------------------------------------------------------------------
; Method:    NetComAddrCollection.Compare
; Purpose:   Compare 2 NETCOMADDR_ENTRYs
; Arguments: Arg1: -> First NETCOMADDR.
;            Arg2: -> Second NETCOMADDR (Search key).
; Return:    eax = Compare result.

Method NetComAddrCollection.Compare,, pItem1:PNETCOMADDR, pItem2:PNETCOMADDR
  mov xcx, pItem1
  mov xdx, pItem2
  mov ax, [xcx].NETCOMADDR.wFamily
  sub ax, [xdx].NETCOMADDR.wFamily
  .if ZERO?
    .if [xcx].NETCOMADDR.wFamily == AF_INET
      mov eax, DWORD ptr [xcx].NETCOMADDR.Address          ;This address fits in a 32 bit register
      sub eax, DWORD ptr [xdx].NETCOMADDR.Address
      DbgHex eax,, "NetComAddrCollection"
;      .if ZERO?
;        mov ax, [xcx].NETCOMADDR.wPort
;        sub ax, [xdx].NETCOMADDR.wPort
;        movsx eax, ax
;      .endif
    .elseif [xcx].NETCOMADDR.wFamily == AF_INET6
      invoke MemComp, addr [xcx].NETCOMADDR.Address, \
                      addr [xdx].NETCOMADDR.Address, \
                      sizeof IN6_ADDR
;      .if eax == 0
;        mov xcx, pItem1
;        mov xdx, pItem2
;        mov ax, [xcx].NETCOMADDR.Address
;        sub ax, [xdx].NETCOMADDR.Address
;        movsx eax, ax
;      .endif
    .else
      DbgWarning "NetComAddrCollection.Compare - ss_family comparison not implemented"
      mov eax, -1
    .endif
  .endif
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:    NetComAddrCollection.Init
; Purpose:   Initialize the NetComAddrCollection object.
; Arguments: Arg1: -> Owner object.
;            Arg2: Limit value of the collection (items).
;            Arg3: Growing factor of the collection (items).
;            Arg4: Maximum size of the collection (items).
; Return:    eax = Zero if succeeded, otherwise an error code.

Method NetComAddrCollection.Init, uses xsi, pOwner:POINTER, dLimit:DWORD, dDelta:DWORD, \
                                            dMaxCapacity:DWORD
  SetObject xsi
  ACall xsi.Init, pOwner, dLimit, dDelta, dMaxCapacity
  mov [xsi].dDuplicates, FALSE
  xor eax, eax
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComAddrCollection.Insert
; Purpose:    Insert item at the end of the collection.
; Arguments:  Arg1: -> NETCOMADDR.
; Return:     xax -> Inserted item or NULL if failed.

Method NetComAddrCollection.Insert, uses xsi, pItem:POINTER
  local pEntry:PNETCOMADDR

  SetObject xsi
  MemAlloc sizeof NETCOMADDR
  .if xax != NULL
    mov pEntry, xax
    invoke MemClone, xax, pItem, sizeof NETCOMADDR
    ACall xsi.Insert, pEntry
  .else
    OCall xsi.ErrorReport, NULL, COL_OUT_OF_MEMORY
    xor eax, eax                                        ;Return NULL
  .endif
MethodEnd

endif
; ==================================================================================================
; Title:      SRPS.asm
; Author:     G. Friedrich
; Version:    C.2.0
; Purpose:    ObjAsm Small Reverse Proxy Server.
; Notes:      Version C.2.0, December 2025
;               - First release.
; ==================================================================================================


; --------------------------------------------------------------------------------------------------
; Summary:
;   This code implements a minimal bidirectional TCP reverse proxy operating at OSI Layer 4,
;   built on top of the NetCom engine.
;   The system provides a Windows SDI GUI for configuring local host and destination addresses and
;   ports, controlling the reverse proxy, and monitoring runtime state.
;
;   The Application object manages the dialog lifecycle, initializes and finalizes the embedded
;   NetComEngine, validates user input, populates local IP addresses, and enables/disables UI
;   controls dynamically. Runtime flags track the application state (e.g., running or idle),
;   while event handlers respond to Start, Stop, and Cancel commands.
;
;   The NetComSrpsProtocol object implements the core reverse proxy logic. It pairs
;   client and server connections, forwards data bidirectionally, and ensures proper cleanup
;   on disconnection. Memory allocation for protocol data, data completeness checks, and queueing
;   of transmitted data are fully encapsulated.
;
;   Together, these modules provide a robust, minimal reverse proxy setup capable of streaming
;   data between clients and servers while maintaining consistent GUI and network state.
;
; --------------------------------------------------------------------------------------------------

; --------------------------------------------------------------------------------------------------
; ToDos:
; 1. Backpressure indicator (TCP Window Full) to slow down WSASend
; 2. Supervisor implementation
; 3. Add CIDR (Classless Inter-Domain Routing) matching to the Blacklist.
; --------------------------------------------------------------------------------------------------


WIN32_LEAN_AND_MEAN         equ 1                       ;Exclude rarely-used Windows headers
INCL_WINSOCK_API_PROTOTYPES equ 1                       ;Enable WinSock API prototypes

PROTOCOL_WND_NAME           textequ <SRPS2> ;<SRPS-Protocol>   Debug/protocol window title
INTERNET_PROTOCOL_VERSION   equ 4                       ;Select IP version (4 or 6)

% include @Environ(OBJASM_PATH)\Code\Macros\Model.inc   ;Include & initialize standard modules
SysSetup OOP, WIN64, ANSI_STRING;, DEBUG(WND)            ;Load OOP files and OS related objects

% include &MacPath&fMath.inc                            ;Floating-point math helpers
% include &MacPath&SDLL.inc                             ;Linked List support macros

% include &IncPath&Windows\WinSock2.inc                 ;WinSock core definitions
% include &IncPath&Windows\ws2ipdef.inc                 ;IP protocol definitions
% include &IncPath&Windows\ws2tcpip.inc                 ;TCP/IP helper APIs
;% include &IncPath&Windows\iphlpapi.inc

% include &IncPath&Windows\ShellApi.inc                 ;Shell API declarations
% include &IncPath&Windows\CommCtrl.inc                 ;Common controls support

% includelib &LibPath&Windows\Ws2_32.lib                ;WinSock 2 library
% includelib &LibPath&Windows\Mswsock.lib               ;Microsoft WinSock extensions
% includelib &LibPath&Windows\Kernel32.lib              ;Core Windows kernel functions
% includelib &LibPath&Windows\Shell32.lib               ;Shell functionality
% includelib &LibPath&Windows\Iphlpapi.lib              ;IP Helper API (adapter enumeration, etc.)

if INTERNET_PROTOCOL_VERSION eq 4
  AF_INETX  equ   AF_INET                               ;Use IPv4 address family
elseif INTERNET_PROTOCOL_VERSION eq 6
  AF_INETX  equ   AF_INET6                              ;Use IPv6 address family
else
  %.err <NetComEngine.Init - wrong IP version: $ToStr(%INTERNET_PROTOCOL_VERSION)>
endif


;Load or build the following objects
MakeObjects Primer, Stream, DiskStream, Collection, DataPool, StopWatch
MakeObjects DataCollection, XWCollection, SortedCollection, SortedDataCollection
MakeObjects WinPrimer, Window, Button, Hyperlink
MakeObjects Dialog, DialogModal, DialogAbout
MakeObjects WinApp, DlgApp
MakeObjects NetCom


include SRPS_Globals.inc                                ;Application globals
include SRPS_Main.inc                                   ;Application object

.code
start proc                                              ;Program entry point
  SysInit                                               ;Runtime initialization of OOP model

  DbgClearTxt "SRPS"                                    ;Clear this DbgCenter text window
  DbgClearTxt "&PROTOCOL_WND_NAME"                      ;Clear this DbgCenter text window
  DbgClearTxt "NetComConnectionPool"
  OCall $ObjTmpl(Application)::Application.Init         ;Initialize application
  OCall $ObjTmpl(Application)::Application.Run          ;Execute application
  OCall $ObjTmpl(Application)::Application.Done         ;Finalize application

  SysDone                                               ;Runtime finalization of the OOP model
  invoke ExitProcess, 0                                 ;Exit program returning 0 to the OS
start endp

end

; ==================================================================================================
; Title:      SRPS_Main.inc
; Author:     G. Friedrich
; Purpose:    See SRPS.asm
; ==================================================================================================


; --------------------------------------------------------------------------------------------------
; Concept:
;                      Client Connections        Server Connections
;
;                     Remote         Local      Local         Remote            Peer Connections
;                    Endpoint      Endpoint    Endpoint      Endpoint               (A - a)
;                                                                                   (B - b)
;              +--------+              +----------+                                 (C - c)
;              | Client o---A--        |          o<--a--
;              +--------+      |       |          |      |
;                              |       |          |      |       +--------+
;              +--------+       ----   |          |       ----   |        |
;              | Client o<--B-------|->o   SRPS   o<--b-------|->o Server |
;              +--------+       ----   |          |       ----   |        |
;                              |       |          |      |       +--------+
;              +--------+      |       |          |      |
;              | Client o<--C--        |          o<--c--
;              +--------+              +----------+
;
;   The diagram illustrates the architecture of the reverse proxy system implemented by SRPS.
;   - Client: Represents the originating application or system that initiates a network connection.
;   - SRPS:   Acts as the reverse proxy, receiving connections from the client and forwarding them
;             to the designated server. It handles bidirectional data transfer, connection pairing,
;             and protocol management. It also provides a Windows GUI for configuration and control.
;   - Server: The backend system that ultimately receives the proxied connections and responds
;             to client requests.
;
;   Data flows bidirectionally between the Client and Server through the SRPS reverse proxy,
;   allowing seamless communication while enabling monitoring, address/port translation, and
;   connection control.
;
; --------------------------------------------------------------------------------------------------


APF_RUNNING   equ   BIT00                         ;Application is currently running

WM_SHOWMSG    equ   WM_APP

MSG_INFO struct
  pMessage    PSTRING   ?
  pCaption    PSTRING   ?
  dType       DWORD     ?
  cBuffer     CHR       0 DUP (?)  
MSG_INFO ends
PMSG_INFO typedef ptr MSG_INFO

MSG_INFO_SIZE equ 1024

; --------------------------------------------------------------------------------------------------
; Object:     Application
; Purpose:    Main application dialog.

Object Application,, DlgApp
  VirtualMethod     CtlsEnable,       DWORD             ;Enable/disable UI controls
  RedefineMethod    CtlsGet                             ;Read dialog values
  RedefineMethod    CtlsSet                             ;Update dialog controls
  RedefineMethod    Done                                ;Cleanup resources
  RedefineMethod    Init                                ;Initialize dialog

  VirtualEvent      OnCommand,        WM_COMMAND        ;Handle WM_COMMAND messages
  VirtualEvent      OnShowMsg,        WM_SHOWMSG        ;Handle WM_SHOWMSG messages
  VirtualEvent      OnTimer,          WM_TIMER          ;Handle WM_TIMER messages

  DefineVariable    dFlags,           DWORD,          0 ;Runtime state flags
  DefineVariable    hTimer,           HANDLE,         0

  Embed  RevProxy,  NetComEngine                        ;Embedded reverse proxy engine
ObjectEnd


include SRPS_Protocol.inc

TIMER_ID  equ   126985

.code
; ==================================================================================================
;    Application implementation
; ==================================================================================================


.code

; --------------------------------------------------------------------------------------------------
; Procedure:  IsUnsignedDecimalString
; Purpose:    Checks if the input string is a unsigned decimal number.
; Arguments:  Arg1: -> Input string.
; Return:     eax = TRUE if a unsigned decimal number was detected, otherwise FALSE.

IsUnsignedDecimalString proc pString:PSTRING
  xor eax, eax
  ?mov xcx, pString
  .if xcx != NULL && CHR ptr [xcx] != 0
    .while TRUE
      movzx edx, CHR ptr [xcx]
      .if edx == 0
        inc eax
        .break
      .endif
      .break .if edx < "0" || edx > "9"
      add xcx, sizeof CHR
    .endw
  .endif
  ret
IsUnsignedDecimalString endp

; --------------------------------------------------------------------------------------------------
; Method:     Application.CtlsEnable
; Purpose:    Enables or disables the dialog controls.
; Arguments:  Arg1: TRUE = enabled, FALSE = disabled.
; Return:     Nothing.

Method Application.CtlsEnable, uses xbx xsi, dEnable:DWORD
  SetObject xsi                                         ;Bind object context

  ;Handle inner controls - enable/disable them
  invoke GetDlgItem, [xsi].hWnd, IDC_CBO_CLIENT_LOCAL_ADDR    ;Client local address combobox control
  invoke EnableWindow, xax, dEnable                           ;Enable/disable control
  invoke GetDlgItem, [xsi].hWnd, IDC_EDT_CLIENT_LOCAL_PORT    ;Client local port edit control
  invoke EnableWindow, xax, dEnable                           ;Enable/disable control
  invoke GetDlgItem, [xsi].hWnd, IDC_UDN_CLIENT_LOCAL_PORT    ;Client local port up/down control
  invoke EnableWindow, xax, dEnable                           ;Enable/disable control

  invoke GetDlgItem, [xsi].hWnd, IDC_CBO_SERVER_LOCAL_ADDR    ;Server local address combobox control
  invoke EnableWindow, xax, dEnable                           ;Enable/disable control
  invoke GetDlgItem, [xsi].hWnd, IDC_CHK_SERVER_USE_EPHEM_PORT;Server local ephem. checkbox control
  invoke EnableWindow, xax, dEnable                           ;Enable/disable control
  invoke GetDlgItem, [xsi].hWnd, IDC_EDT_SERVER_LOCAL_PORT    ;Server local port edit control
  invoke EnableWindow, xax, dEnable                           ;Enable/disable control
  invoke GetDlgItem, [xsi].hWnd, IDC_UDN_SERVER_LOCAL_PORT    ;Server local port up/down control
  invoke EnableWindow, xax, dEnable                           ;Enable/disable control
  invoke GetDlgItem, [xsi].hWnd, IDC_CBO_SERVER_REMOTE_ADDR   ;Server remote IP address control
  invoke EnableWindow, xax, dEnable                           ;Enable/disable control
  invoke GetDlgItem, [xsi].hWnd, IDC_EDT_SERVER_REMOTE_PORT   ;Server remote port edit control
  invoke EnableWindow, xax, dEnable                           ;Enable/disable control
  invoke GetDlgItem, [xsi].hWnd, IDC_UDN_SERVER_REMOTE_PORT   ;Server remote port up/down control
  invoke EnableWindow, xax, dEnable                           ;Enable/disable control

  ;Handle buttons - switch between Start and Stop
  .if dEnable != FALSE
    mov ebx, IDC_BTN_START                              ;Enable Start button
    mov edx, IDC_BTN_STOP                               ;Disable Stop button
  .else
    mov ebx, IDC_BTN_STOP                               ;Enable Stop button
    mov edx, IDC_BTN_START                              ;Disable Start button
  .endif
  invoke GetDlgItem, [xsi].hWnd, edx
  invoke EnableWindow, xax, FALSE                       ;Disable inactive button
  invoke GetDlgItem, [xsi].hWnd, ebx
  invoke EnableWindow, xax, TRUE                        ;Enable active button
  invoke SendMessage, [xsi].hWnd, DM_SETDEFID, ebx, 0   ;Set default dialog button
  invoke GetDlgItem, [xsi].hWnd, ebx
  invoke SetFocus, xax                                  ;Move keyboard focus
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     Application.CtlsGet
; Purpose:    Get dialog controls.
; Arguments:  None.
; Return:     eax = TRUE if succeeded or FALSE otherwise.

Method Application.CtlsGet, uses xdi xbx xsi
  local dRetValue:DWORD, dSucceeded:DWORD, Hints:ADDRINFOT, pResult:PADDRINFOT
  local cClientLocalAddr[32]:CHR, cClientLocalServiceName[32]:CHR
  local cServerLocalAddr[32]:CHR, cServerLocalServiceName[32]:CHR
  local cServerRemoteAddr[32]:CHR, cServerRemoteServiceName[32]:CHR
  local cBuffer:DWORD

  DbgText "Application.CtlsGet"
  SetObject xsi

  ;Read client local IP
  mov xdi, $invoke(GetDlgItem, [xsi].hWnd, IDC_CBO_CLIENT_LOCAL_ADDR)
  invoke SendMessage, xdi, CB_GETCURSEL, 0, 0
  lea xbx, cClientLocalAddr
  invoke SendMessage, xdi, CB_GETLBTEXT, eax, xbx       ;Can only return valid addresses

  ;Read client local port (listening port)
  invoke GetDlgItemInt, [xsi].hWnd, IDC_EDT_CLIENT_LOCAL_PORT, addr dSucceeded, FALSE
  .if dSucceeded != FALSE && ax > 0 && ax <= 0FFFFh
    invoke GetDlgItemText, [xsi].hWnd, IDC_EDT_CLIENT_LOCAL_PORT, \
                           addr cClientLocalServiceName, lengthof cClientLocalServiceName
  .else
    invoke MessageBox, [xsi].hWnd, $OfsCStr("Incorrect client local port number"), \
                       addr cError, MB_OK or MB_ICONERROR
    xor eax, eax
    ExitMethod
  .endif

  ;Read server local IP
  mov xdi, $invoke(GetDlgItem, [xsi].hWnd, IDC_CBO_SERVER_LOCAL_ADDR)
  invoke SendMessage, xdi, CB_GETCURSEL, 0, 0
  lea xbx, cServerLocalAddr
  invoke SendMessage, xdi, CB_GETLBTEXT, eax, xbx       ;Can only return valid addresses

  lea xbx, $ObjTmpl(NetComSrpsProtocol)

  ;Read server use ephemeral port
  invoke IsDlgButtonChecked, [xsi].hWnd, IDC_CHK_SERVER_USE_EPHEM_PORT
  xor ecx, ecx
  cmp eax, BST_CHECKED
  setz cl
  mov [xbx].$Obj(NetComSrpsProtocol).dUseEphemeralPort, ecx

  ;Read server local port
  .if ecx == FALSE
    invoke GetDlgItemInt, [xsi].hWnd, IDC_EDT_SERVER_LOCAL_PORT, addr dSucceeded, FALSE
    .if dSucceeded != FALSE && ax > 0 && ax <= 0FFFFh
      invoke GetDlgItemText, [xsi].hWnd, IDC_EDT_SERVER_LOCAL_PORT, \
                             addr cServerLocalServiceName, lengthof cServerLocalServiceName
    .else
      invoke MessageBox, [xsi].hWnd, $OfsCStr("Incorrect server connection local port number"), \
                         addr cError, MB_OK or MB_ICONERROR
      xor eax, eax
      ExitMethod
    .endif
  .else
    FillString cServerLocalServiceName, <0>
  .endif

  ;Read server remote IP
  mov xdi, $invoke(GetDlgItem, [xsi].hWnd, IDC_CBO_SERVER_REMOTE_ADDR)
  invoke SendMessage, xdi, CB_GETCURSEL, 0, 0
  lea xbx, cServerRemoteAddr
  invoke SendMessage, xdi, CB_GETLBTEXT, eax, xbx       ;Can only return valid addresses

  ;Read server remote port
  invoke GetDlgItemInt, [xsi].hWnd, IDC_EDT_SERVER_REMOTE_PORT, addr dSucceeded, FALSE
  .if dSucceeded != FALSE && ax > 0 && ax <= 0FFFFh
    invoke GetDlgItemText, [xsi].hWnd, IDC_EDT_SERVER_REMOTE_PORT, \
                           addr cServerRemoteServiceName, lengthof cServerRemoteServiceName
  .else
    invoke MessageBox, [xsi].hWnd, $OfsCStr("Incorrect server remote port number"), \
                       addr cError, MB_OK or MB_ICONERROR
    xor eax, eax
    ExitMethod
  .endif

  ; --------------------------------------------------------------------------------
  ; Get network components
  ; --------------------------------------------------------------------------------

  mov dRetValue, FALSE

  mov Hints.ai_flags, AI_NUMERICHOST or \       ;Only numeric host allowed
                      AI_PASSIVE                ;Socket address will be used with a bind call
  mov Hints.ai_family, AF_INETX                 ;IPv4/IPv6 family
  mov Hints.ai_socktype, SOCK_STREAM            ;TCP socket
  mov Hints.ai_protocol, IPPROTO_TCP            ;TCP protocol
  mov Hints.ai_addrlen, 0                       ;Must be set to zero
  mov Hints.ai_canonname, NULL                  ;Must be set to NULL
  mov Hints.ai_addr, NULL                       ;Must be set to NULL
  mov Hints.ai_next, NULL                       ;Must be set to NULL

  ;Get client local NETCOMADDR ----------------------------
  ;Compare with "ANY", if iqual => use NULL as pNodeName argument for GetAddrInfo
  lea xbx, $ObjTmpl(NetComSrpsProtocol)
  invoke StrComp, addr cClientLocalAddr, addr cAny
  xor ecx, ecx
  .if eax != 0
    lea xcx, cClientLocalAddr
  .endif
  invoke GetAddrInfo, xcx, addr cClientLocalServiceName, addr Hints, addr pResult
  .if eax != 0
    invoke WSAGetLastError
    invoke WsaErrBox, [xsi].hWnd, $OfsCStr("Incorrect client local address or port number"), \
                       offset cError, MB_OK or MB_ICONERROR, eax
    jmp @@Exit
  .endif
  mov xax, pResult
  lea xcx, [xbx].$Obj(NetComSrpsProtocol).ListeningAddr
  invoke MemClone, xcx, [xax].ADDRINFOT.ai_addr, DWORD ptr [xax].ADDRINFOT.ai_addrlen
  invoke FreeAddrInfo, pResult                          ;Free memory

  ;Get Server local NETCOMADDR ----------------------------
  mov Hints.ai_flags, AI_NUMERICHOST                    ;Only numeric host allowed
  invoke StrComp, addr cServerLocalAddr, addr cAuto
  xor ecx, ecx
  .if eax != 0
    lea xcx, cServerLocalAddr
  .endif
  xor edx, edx
  .if [xbx].$Obj(NetComSrpsProtocol).dUseEphemeralPort == FALSE
    lea xdx, cServerLocalServiceName
  .endif
  .if xcx != NULL || xdx != NULL
    invoke GetAddrInfo, xcx, xdx, addr Hints, addr pResult
    .if eax != 0
      invoke WSAGetLastError
      invoke WsaErrBox, [xsi].hWnd, $OfsCStr("Incorrect server local address or port number"), \
                         offset cError, MB_OK or MB_ICONERROR, eax
      jmp @@Exit
    .endif
    mov xax, pResult
    lea xcx, [xbx].$Obj(NetComSrpsProtocol).ServerLocalAddr
    invoke MemClone, xcx, [xax].ADDRINFOT.ai_addr, DWORD ptr [xax].ADDRINFOT.ai_addrlen
    invoke FreeAddrInfo, pResult                        ;Free memory
  .else
    lea xdi, [xbx].$Obj(NetComSrpsProtocol).ServerLocalAddr
    invoke MemZero, xdi, sizeof NETCOMADDR
    mov [xdi].NETCOMADDR.wFamily, AF_INETX
  .endif
  DbgNetComAddrIPV4 [xbx].$Obj(NetComSrpsProtocol).ServerLocalAddr, "Application.CtlsGet - Server Local Address"

  ;Get Server remote NETCOMADDR ---------------------------
  mov Hints.ai_flags, AI_NUMERICHOST                    ;Only numeric host allowed
  invoke GetAddrInfo, addr cServerRemoteAddr, addr cServerRemoteServiceName, addr Hints, addr pResult  ;Resolve
  .if eax != 0
    invoke WSAGetLastError
    invoke WsaErrBox, [xsi].hWnd, $OfsCStr("Incorrect server remote address or port number"), \
                       offset cError, MB_OK or MB_ICONERROR, eax
    jmp @@Exit
  .endif
  mov xax, pResult
  lea xcx, [xbx].$Obj(NetComSrpsProtocol).ServerRemoteAddr
  invoke MemClone, xcx, [xax].ADDRINFOT.ai_addr, DWORD ptr [xax].ADDRINFOT.ai_addrlen
  invoke FreeAddrInfo, pResult                          ;Free memory
  
  mov dRetValue, TRUE
  DbgNetComAddrIPV4 [xbx].$Obj(NetComSrpsProtocol).ServerRemoteAddr, "Application.CtlsGet - Server Remote Address"

@@Exit:
  mov eax, dRetValue
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     Application.CtlsSet
; Purpose:    Set dialog controls.
; Arguments:  None.
; Return:     Nothing.

Method Application.CtlsSet, uses xbx xdi xsi
  local dSize:DWORD, pAdapter:POINTER, dPort:DWORD, pMibTable:PMIB_IPNET_TABLE2
  local hComboClientLocalAddr:HANDLE, hComboServerLocalAddr:HANDLE, hComboServerRemoteAddr:HANDLE
  local cBuffer[100]:CHR, dBufferLength:DWORD

  DbgText "Application.CtlsSet"
  SetObject xsi
  
  ;Set "Client local address" and "Server local address" comboboxes
  mov hComboClientLocalAddr, $invoke(GetDlgItem, [xsi].hWnd, IDC_CBO_CLIENT_LOCAL_ADDR)
  mov hComboServerLocalAddr, $invoke(GetDlgItem, [xsi].hWnd, IDC_CBO_SERVER_LOCAL_ADDR)
  invoke SendMessage, hComboClientLocalAddr, CB_RESETCONTENT, 0, 0
  invoke SendMessage, hComboClientLocalAddr, CB_ADDSTRING, 0, addr cAny
  invoke SendMessage, hComboServerLocalAddr, CB_RESETCONTENT, 0, 0
  invoke SendMessage, hComboServerLocalAddr, CB_ADDSTRING, 0, addr cAuto

  invoke GetAdaptersAddresses, AF_INETX, 0, NULL, NULL, addr dSize   ;Get buffer size
  MemAlloc dSize                                        ;Allocate buffer
  .if xax != NULL
    mov pAdapter, xax
    invoke GetAdaptersAddresses, AF_INETX, 0, NULL, pAdapter, addr dSize  ;Get adapter data
    .if eax == ERROR_SUCCESS
      ;Iterate adapters
      mov xbx, pAdapter
      .while xbx != NULL
        mov xdi, [xbx].IP_ADAPTER_ADDRESSES.FirstUnicastAddress
        ;Iterate unicast addresses
        .while xdi != NULL
          invoke getnameinfo, [xdi].IP_ADAPTER_UNICAST_ADDRESS.Address.lpSockaddr, \
                              [xdi].IP_ADAPTER_UNICAST_ADDRESS.Address.iSockaddrLength, \
                              addr cBuffer, sizeof cBuffer, \
                              NULL, 0, \
                              NI_NUMERICHOST
          .break .if eax != ERROR_SUCCESS
          invoke SendMessage, hComboClientLocalAddr, CB_ADDSTRING, 0, addr cBuffer
          invoke SendMessage, hComboServerLocalAddr, CB_ADDSTRING, 0, addr cBuffer
          mov xdi, [xdi].IP_ADAPTER_UNICAST_ADDRESS.Next  ;Next unicast address
        .endw
        mov xbx, [xbx].IP_ADAPTER_ADDRESSES.Next        ;Next adapter
      .endw
    .endif
    MemFree pAdapter                                    ;Free allocated memory buffer
  .endif
  invoke SendMessage, hComboClientLocalAddr, CB_SETCURSEL, 0, 0
  invoke SendMessage, hComboServerLocalAddr, CB_SETCURSEL, 0, 0

  ;Set "Client local port" edit control limits and value
  lea xbx, $ObjTmpl(NetComSrpsProtocol)
  invoke htons, [xbx].$Obj(NetComSrpsProtocol).ListeningAddr.wPort
  mov dPort, eax
  invoke SetDlgItemInt, [xsi].hWnd, IDC_EDT_CLIENT_LOCAL_PORT, dPort, FALSE   ;Update listening port

  ;Set "Client local port" up/down control limits and value
  mov xdi, $invoke(GetDlgItem, [xsi].hWnd, IDC_UDN_CLIENT_LOCAL_PORT)
  invoke SendMessage, xdi, UDM_SETBASE, 10, 0
  invoke SendMessage, xdi, UDM_SETRANGE32, 1, 0FFFFh
  invoke SendMessage, xdi, UDM_SETPOS32, 0, dPort

  ;Check/uncheck "use ephemeral port" control
  mov eax, BST_CHECKED
  .if [xbx].$Obj(NetComSrpsProtocol).dUseEphemeralPort == FALSE
    mov eax, BST_UNCHECKED
  .endif
  invoke CheckDlgButton, [xsi].hWnd, IDC_CHK_SERVER_USE_EPHEM_PORT, eax

  ;Set "Server remote address" combobox
  mov hComboServerRemoteAddr, $invoke(GetDlgItem, [xsi].hWnd, IDC_CBO_SERVER_REMOTE_ADDR)
  invoke SendMessage, hComboServerRemoteAddr, CB_RESETCONTENT, 0, 0

  ;Add local adapter IPs
  invoke GetAdaptersAddresses, AF_INETX, 0, NULL, NULL, addr dSize   ;Get buffer size
  MemAlloc dSize                                        ;Allocate buffer
  .if xax != NULL
    mov pAdapter, xax
    invoke GetAdaptersAddresses, AF_INETX, 0, NULL, pAdapter, addr dSize  ;Get adapter data
    .if eax == ERROR_SUCCESS
      ;Iterate adapters
      mov xbx, pAdapter
      .while xbx != NULL
        mov xdi, [xbx].IP_ADAPTER_ADDRESSES.FirstUnicastAddress
        ;Iterate unicast addresses
        .while xdi != NULL
          invoke getnameinfo, [xdi].IP_ADAPTER_UNICAST_ADDRESS.Address.lpSockaddr, \
                              [xdi].IP_ADAPTER_UNICAST_ADDRESS.Address.iSockaddrLength, \
                              addr cBuffer, sizeof cBuffer, \
                              NULL, 0, \
                              NI_NUMERICHOST
          .break .if eax != ERROR_SUCCESS
          invoke SendMessage, hComboServerRemoteAddr, CB_ADDSTRING, 0, addr cBuffer
          mov xdi, [xdi].IP_ADAPTER_UNICAST_ADDRESS.Next  ;Next unicast address
        .endw
        mov xbx, [xbx].IP_ADAPTER_ADDRESSES.Next        ;Next adapter
      .endw
    .endif
    MemFree pAdapter                                    ;Free allocated memory buffer
  .endif
  
  ;Add known neighbor IPs
  invoke GetIpNetTable2, AF_INETX, addr pMibTable
  .if eax == NO_ERROR
    mov xdi, pMibTable
    mov ebx, [xdi].MIB_IPNET_TABLE2.NumEntries
    lea xdi, [xdi].MIB_IPNET_TABLE2.Table
    test ebx, ebx
    .while !ZERO?
      mov dBufferLength, lengthof(cBuffer)
      invoke WSAAddressToString, addr [xdi].MIB_IPNET_ROW2.Address, sizeof SOCKADDR_INET, NULL, addr cBuffer, addr dBufferLength
      .if eax == NO_ERROR
        invoke SendMessage, hComboServerRemoteAddr, CB_ADDSTRING, 0, addr cBuffer
      .endif
      add xdi, sizeof(MIB_IPNET_ROW2)
      dec ebx
    .endw
    invoke FreeMibTable, pMibTable
  .endif
  
  invoke SendMessage, hComboServerRemoteAddr, CB_SETCURSEL, 0, 0

  ;Enable/disable "Server local port" edit control
  lea xbx, $ObjTmpl(NetComSrpsProtocol)
  invoke GetDlgItem, [xsi].hWnd, IDC_EDT_SERVER_LOCAL_PORT
  xor edx, edx
  cmp [xbx].$Obj(NetComSrpsProtocol).dUseEphemeralPort, FALSE
  setz dl
  invoke EnableWindow, xax, edx

  ;Set "Server local port" edit control
  invoke htons, [xbx].$Obj(NetComSrpsProtocol).ServerRemoteAddr.wPort
  mov dPort, eax
  invoke SetDlgItemInt, [xsi].hWnd, IDC_EDT_SERVER_REMOTE_PORT, dPort, FALSE  ;Update Server port

  ;Set server local port up/down control limits and value
  mov xdi, $invoke(GetDlgItem, [xsi].hWnd, IDC_UDN_SERVER_REMOTE_PORT)
  invoke SendMessage, xdi, UDM_SETBASE, 10, 0
  invoke SendMessage, xdi, UDM_SETRANGE32, 1, 0FFFFh
  invoke SendMessage, xdi, UDM_SETPOS32, 0, dPort
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     Application.Done
; Purpose:    Finalize the application object and frees allocated resources.
; Arguments:  None.
; Return:     Nothing.

Method Application.Done, uses xsi
  SetObject xsi                                         ;Bind object context
  invoke KillTimer, [xsi].hWnd, TIMER_ID
  OCall [xsi].RevProxy::NetComEngine.StopListening
  OCall [xsi].RevProxy::NetComEngine.Done
  OCall $ObjTmpl(NetComSrpsProtocol)::NetComSrpsProtocol.Done
  ACall xsi.Done                                        ;Call ancestor Done method
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     Application.Init
; Purpose:    Initialize the application object.
; Arguments:  None.
; Return:     Nothing.

Method Application.Init, uses xbx xsi
  local cBuffer[1024]:CHR

  SetObject xsi
  ACall xsi.Init                                        ;Call ancestor Init
  invoke CreateDialogParam, hInstance, IDD_DLG_MAIN, 0, $MethodAddr(DlgApp.WndProc), xsi
  .if xax == NULL
    DbgApiError
    lea xbx, cBuffer
    WriteF xbx, "\`吁T\` failed to start\:", offset szAppTitle ;Prepare error message
    invoke MessageBox, 0, addr cBuffer, addr cError, MB_OK or MB_ICONERROR or MB_TASKMODAL
    invoke ExitProcess, 1                               ;Exit program with failure
  .else
    invoke LoadIcon, hInstance, offset szIcoName
    invoke SendMessage, [xsi].hWnd, WM_SETICON, ICON_BIG, xax   ;Set big icon
    invoke SendMessage, [xsi].hWnd, WM_SETICON, ICON_SMALL, xax ;Set small icon

    OCall $ObjTmpl(NetComSrpsProtocol)::NetComSrpsProtocol.Init, xsi
    .if eax != 0
      lea xbx, cBuffer
      WriteF xbx, "\`吁T\` failed to initialize the Reverse Proxy protocol\:", offset szAppTitle ;Prepare error message
      invoke MessageBox, 0, addr cBuffer, addr cError, MB_OK or MB_ICONERROR or MB_TASKMODAL
      invoke ExitProcess, 1                               ;Exit program with failure
    .endif
  .endif
  OCall [xsi].RevProxy::NetComEngine.Init, xsi, 50, 1000, MSS_ETHERNET_IPVX ;Init network engine
  .if eax != 0
    invoke MessageBox, [xsi].hWnd, $OfsCStr("Failed to start the NetCom engine"), \
                       addr cError, MB_OK or MB_ICONERROR ;Show error
    invoke ExitProcess, 1                                 ;Exit program with failure
  .endif

  invoke SetWindowText, [xsi].hWnd, offset szAppTitle
  invoke SetTimer, [xsi].hWnd, TIMER_ID, 1000, NULL
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     Application.OnCommand
; Purpose:    Event procedure for WM_COMMAND message.
; Arguments:  Arg1: First message parameter.
;             Arg2: Second message parameter.
; Return:     eax = If an application processes this message, it should return zero.

Method Application.OnCommand, uses xbx xsi, wParam:WPARAM, lParam:LPARAM

  SetObject xsi
  mov xax, wParam

  .if ax == IDC_BTN_START
    OCall xsi.CtlsGet                                   ;Read dialog controls
    .if eax != FALSE
      ;16 pending acceptors is a regular number on most servers
      mov xax, offset $ObjTmpl(NetComSrpsProtocol)
      DbgHex xax, "pProtocol"
      OCall [xsi].RevProxy::NetComEngine.StartListening, 16, offset $ObjTmpl(NetComSrpsProtocol)
      .if eax == NO_ERROR
        DbgText "Reverse Proxy is listening"            ;Debug message
        DbgLine2
        BitSet [xsi].dFlags, APF_RUNNING                ;Mark as running
        OCall xsi.CtlsEnable, FALSE                     ;Disable controls
      .endif
    .endif
    xor eax, eax                                        ;Return zero

  .elseif ax == IDC_BTN_STOP
    OCall [xsi].RevProxy::NetComEngine.StopListening
    OCall [xsi].RevProxy::NetComEngine.ConnectionsDestroy
    OCall [xsi].RevProxy::NetComEngine.ConnectionsClose
    BitClr [xsi].dFlags, APF_RUNNING                    ;Clear running flag
    OCall xsi.CtlsEnable, TRUE                          ;Re-enable controls
    xor eax, eax                                        ;Return zero

  .elseif ax == IDCANCEL
    .ifBitSet [xsi].dFlags, APF_RUNNING
      invoke MessageBox, [xsi].hWnd, $OfsCStr("Are you sure you want to exit?"), \
                         $OfsCStr("Application exit"), MB_YESNO or MB_ICONQUESTION ;Confirm exit
      .if eax == IDYES
        invoke DestroyWindow, [xsi].hWnd                ;Destroy dialog
      .endif
    .else
      invoke DestroyWindow, [xsi].hWnd                  ;Destroy dialog without prompt
    .endif
    xor eax, eax                                        ;Return zero

  .elseif ax == IDC_CHK_SERVER_USE_EPHEM_PORT
    invoke IsDlgButtonChecked, [xsi].hWnd, IDC_CHK_SERVER_USE_EPHEM_PORT
    xor ebx, ebx
    cmp eax, BST_UNCHECKED
    setz bl
    invoke GetDlgItem, [xsi].hWnd, IDC_EDT_SERVER_LOCAL_PORT ;Server local port edit control
    invoke EnableWindow, xax, ebx                       ;Enable/disable control
    xor eax, eax                                        ;Return zero

  .else
    xor eax, eax
    inc eax                                             ;Return default (unhandled)
  .endif
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     Application.OnShowMsg
; Purpose:    Shows a MessageBox displaying a message.
; Arguments:  Arg1: -> MSG_INFO.
;             Arg2: Dummy.
; Return:     Nothing.

Method Application.OnShowMsg, uses xbx, pMsgInfo:WPARAM, lParam:LPARAM
  SetObject xcx
  mov xbx, pMsgInfo
  invoke MessageBox, [xcx].hWnd, [xbx].MSG_INFO.pMessage, [xbx].MSG_INFO.pCaption, [xbx].MSG_INFO.dType
  MemFree xbx  
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     Application.OnTimer
; Purpose:    Event procedure for WM_TIMER message.
; Arguments:  Arg1: First message parameter.
;             Arg2: Second message parameter.
; Return:     eax = Zero if handled.

Method Application.OnTimer, uses xbx xdi xsi, wParam:WPARAM, lParam:LPARAM
  local cBuffer[1024]:CHR

  SetObject xsi

  ;Set application caption
  lea xdi, cBuffer
  lea xbx, [xsi].RevProxy
  WriteF xdi, "吁T - 各D/各D", offset szAppTitle, \
                              [xbx].$Obj(NetComEngine).Connections.dCount, \
                              [xbx].$Obj(NetComEngine).IOSockJobs.dCount   

  invoke SetWindowText, [xsi].hWnd, addr cBuffer
MethodEnd

; ==================================================================================================
; Title:      SRPS_Protocol.inc
; Author:     G. Friedrich
; Version:    See SRPS.asm
; Purpose:    Protocol for a bidirectional Smart Reverse Proxy Server.
; Note:       Minimal TCP reverse proxy (forwarding) using NetCom.
; ==================================================================================================


DEFAULT_SERVER_LISTENING_PORT equ $htons(25773)


; --------------------------------------------------------------------------------------------------
; Concept:
;                      Client Connections        Server Connections
;
;                     Remote         Local      Local         Remote            Peer Connections
;                    Endpoint      Endpoint    Endpoint      Endpoint               (A - a)
;                                                                                   (B - b)
;              +--------+              +----------+                                 (C - c)
;              | Client o---A--        |          o<--a--
;              +--------+      |       |          |      |
;                              |       |          |      |       +--------+
;              +--------+       ----   |          |       ----   |        |
;              | Client o<--B-------|->o   SRPS   o<--b-------|->o Server |
;              +--------+       ----   |          |       ----   |        |
;                              |       |          |      |       +--------+
;              +--------+      |       |          |      |
;              | Client o<--C--        |          o<--c--
;              +--------+              +----------+
;
;
; --------------------------------------------------------------------------------------------------

SRPS_DEFAULT_LISTENING_PORT equ $htons(25772)

SRPS_CONNECTION_DATA struc
  pPeerConnection $ObjPtr(NetComConnection) ?   ;Paired connection (Client <=> Server)
SRPS_CONNECTION_DATA ends

Object NetComSrpsProtocol,, NetComProtocol
  RedefineMethod    Allocate,           $ObjPtr(NetComConnection)
  RedefineMethod    IsDataComplete?,    $ObjPtr(NetComConnection), PIO_SOCKJOB
  RedefineMethod    OnAccepted,         $ObjPtr(NetComConnection)
  RedefineMethod    OnConnected,        $ObjPtr(NetComConnection)
  RedefineMethod    OnDisconnected,     $ObjPtr(NetComConnection), DWORD
  RedefineMethod    OnError,            $ObjPtr(NetComConnection), PIO_SOCKJOB, DWORD
  RedefineMethod    ProcessData,        $ObjPtr(NetComConnection), DWORD
  RedefineMethod    Release,            $ObjPtr(NetComConnection)
  VirtualMethod     ShowErrorBox,       PSTRING, DWORD

  RedefineVariable  ListeningAddr,      {AF_INETX, SRPS_DEFAULT_LISTENING_PORT}

  DefineVariable    dUseEphemeralPort,  DWORD,      TRUE          ;Setup value
  DefineVariable    ServerLocalAddr,    NETCOMADDR, {AF_INETX, 0} ;Setup Server IP + Port
  DefineVariable    ServerRemoteAddr,   NETCOMADDR, {AF_INETX, DEFAULT_LISTENING_PORT}
ObjectEnd


; ==================================================================================================

if IMPLEMENT

; ==================================================================================================
;    NetComSrpsProtocol implementation
; ==================================================================================================

; --------------------------------------------------------------------------------------------------
; Method:     NetComSrpsProtocol.Allocate
; Purpose:    Allocates a memory block for management data on a per connection basis.
;             Additional resources can be reserved here.
; Arguments:  Arg1: -> NetComConnection
; Return:     Zero if succeeded, otherwise an error code.

Method NetComSrpsProtocol.Allocate,, pConnection:$ObjPtr(NetComConnection)
;  DbgHex pConnection, "NetComSrpsProtocol.Allocate", "&PROTOCOL_WND_NAME"
  MemAlloc sizeof SRPS_CONNECTION_DATA, MEM_INIT_ZERO
  .if xax != NULL
    mov xcx, pConnection
    mov [xcx].$Obj(NetComConnection).pData, xax
    xor eax, eax
  .else
    OCall ErrorReport, NULL, NCSP_OUT_OF_MEMORY
  .endif
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComSrpsProtocol.IsDataComplete?
; Purpose:    Determines if received data is complete.
;             Streaming proxy: any completed IO job is valid.
; Arguments:  Arg1: -> NetComConnection
; Return:     eax = This many bytes are valid buffer information.

Method NetComSrpsProtocol.IsDataComplete?,, pConnection:$ObjPtr(NetComConnection), \
                                            pIOSockJob:PIO_SOCKJOB
;  DbgHex pConnection, "NetComSrpsProtocol.IsDataComplete?", "&PROTOCOL_WND_NAME"
  mov xcx, pIOSockJob
  mov eax, [xcx].IO_SOCKJOB.dBytesConsumed              ;Send what was recieved
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComSrpsProtocol.OnAccepted
; Purpose:    An inbound connection 'accept' has completed.
;             Establish backend connection and pair both sides.
; Arguments:  Arg1: -> NetComConnection
; Return:     eax = CMD_ACCEPT_CONNECTION or CMD_REJECT_CONNECTION

Method NetComSrpsProtocol.OnAccepted, uses xbx xsi, pConnection:$ObjPtr(NetComConnection)
  DbgHex pConnection, "NetComSrpsProtocol.OnAccepted", "&PROTOCOL_WND_NAME"
  SetObject xsi
  mov xbx, [xsi].pOwner                                 ;xbx -> Application
  ;Connect to the destination Server
  OCall [xbx].$Obj(Application).RevProxy::NetComEngine.ConnectTo, xsi, \
                                                       addr [xsi].ServerRemoteAddr, \
                                                       addr [xsi].ServerLocalAddr
  .if xax == NULL
    OCall pConnection::NetComConnection.Allow, FALSE
    DbgHex pConnection, "NetComSrpsProtocol.OnAccepted - Connection rejected", "&PROTOCOL_WND_NAME"
  .else
    ;Link connections
    mov xbx, pConnection
    mov xdx, [xbx].$Obj(NetComConnection).pData
    mov [xdx].SRPS_CONNECTION_DATA.pPeerConnection, xax
    mov xdx, [xax].$Obj(NetComConnection).pData
    mov [xdx].SRPS_CONNECTION_DATA.pPeerConnection, xbx

    OCall xbx::NetComConnection.Allow, TRUE
 .endif
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComSrpsProtocol.OnConnected
; Purpose:    An outbound connection attempt has completed.
; Arguments:  Arg1: -> NetComConnection.
; Return:     Nothing.

Method NetComSrpsProtocol.OnConnected,, pConnection:$ObjPtr(NetComConnection)
  DbgHex pConnection, "NetComSrpsProtocol.OnConnected", "&PROTOCOL_WND_NAME"
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComSrpsProtocol.OnDisconnected
; Purpose:    An established connection has been disconnected.
;             Tear down the paired connection as well.
; Arguments:  Arg1: -> NetComConnection
;             Arg2: Disconnect direction = SD_SEND/SD_RECEIVE/SD_BOTH
; Return:     Nothing.

Method NetComSrpsProtocol.OnDisconnected, uses xbx xdi, pConnection:$ObjPtr(NetComConnection), dDirection:DWORD
  DbgHex pConnection, "NetComSrpsProtocol.OnDisconnected", "&PROTOCOL_WND_NAME"
  mov xdi, pConnection
  mov xax, [xdi].$Obj(NetComConnection).pData
  mov xbx, [xax].SRPS_CONNECTION_DATA.pPeerConnection   ;xbx -> peer connection

  .if xbx != NULL
    ;Break links on both connections to avoid recursion
    mov [xax].SRPS_CONNECTION_DATA.pPeerConnection, NULL
    mov xax, [xbx].$Obj(NetComConnection).pData
    mov [xax].SRPS_CONNECTION_DATA.pPeerConnection, NULL
    DbgHex xbx, "NetComSrpsProtocol.OnDisconnected - Peer disconnect - Connection", "&PROTOCOL_WND_NAME"
    ;Disconnect peer connection
    OCall xbx::NetComConnection.Disconnect, SD_SEND     ;Graceful disconnect
    OCall xbx::NetComConnection.QueueDestroy            ;Mark for destruction
    OCall xbx::NetComConnection.Close, FALSE
    OCall xdi::NetComConnection.QueueDestroy            ;Mark for destruction
    OCall xdi::NetComConnection.Close, FALSE
  .endif
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComSrpsProtocol.OnError
; Purpose:    Error notification handler.
; Arguments:  Arg1: -> NetComConnection.
;             Arg2: -> IOSockJob.
;             Arg3: WSA Error code.
; Return:     eax = Command (PROT_CMD_REJECT_CONNECTION, PROT_CMD_CLOSE, ...), if applicable.

Method NetComSrpsProtocol.OnError, uses xbx xdi xsi, pConnection:$ObjPtr(NetComConnection), \
                                                     pIOSockJob:PIO_SOCKJOB, \
                                                     dError:DWORD
  local cBuffer[1024]:CHR

  SetObject xsi
  DbgDec dError, "NetComSrpsProtocol.OnError", "&PROTOCOL_WND_NAME"

  mov xcx, pIOSockJob

  .if xcx != NULL
    movzx eax, [xcx].IO_SOCKJOB.wOperation
    mov xbx, pConnection                                  ;xbx -> connection
    .if eax == OPERATION_SOCK_ACCEPT
      .if dError == WSA_OPERATION_ABORTED
        DbgSockError "NetComSrpsProtocol.OnError - Accept WSA_OPERATION_ABORTED"
        DbgHex xdi, "pConnection"
        OCall xdi::NetComConnection.QueueDestroy
      .else
        DbgSockError "NetComEngine.Worker - Accept ERROR", dError
        DbgHex xdi, "NetComEngine.Worker - pConnection"
      .endif
      mov eax, PROT_CMD_REJECT_CONNECTION

    .elseif eax == OPERATION_SOCK_CONNECT
      mov xax, [xbx].$Obj(NetComConnection).pData
      mov xdi, [xax].SRPS_CONNECTION_DATA.pPeerConnection ;xdi -> peer connection

      ;Break links on both connections to avoid recursion
      mov [xax].SRPS_CONNECTION_DATA.pPeerConnection, NULL
      mov xax, [xdi].$Obj(NetComConnection).pData
      mov [xax].SRPS_CONNECTION_DATA.pPeerConnection, NULL

      ;Disconnect both connections
      DbgText "NetComSrpsProtocol.OnError - QueueDestroy fault connection", "&PROTOCOL_WND_NAME"
      OCall xbx::NetComConnection.QueueDestroy
      OCall xbx::NetComConnection.Close, FALSE
      DbgText "NetComSrpsProtocol.OnError - QueueDestroy peer connection", "&PROTOCOL_WND_NAME"
      OCall xdi::NetComConnection.QueueDestroy
      OCall xdi::NetComConnection.Close, FALSE
      xor eax, eax

    .elseif eax == OPERATION_SOCK_SEND
      .ifBitClr [xbx].$Obj(NetComConnection).dFlags, NCC_CLOSED
        DbgText "*****************************************************************************************************"
        DbgText "*****************************************************************************************************"

        mov xax, [xbx].$Obj(NetComConnection).pData
        mov xdi, [xax].SRPS_CONNECTION_DATA.pPeerConnection     ;xdi -> peer connection
        .if xdi != NULL
          mov [xax].SRPS_CONNECTION_DATA.pPeerConnection, NULL
          OCall xdi::NetComConnection.QueueDestroy              ;Destroy peer connection
          OCall xdi::NetComConnection.Close, TRUE
        .endif
        mov eax, PROT_CMD_DESTROY                               ;Destroy self
      .endif

    .elseif eax == OPERATION_SOCK_RECV
      .ifBitClr [xbx].$Obj(NetComConnection).dFlags, NCC_CLOSED
        DbgText "*****************************************************************************************************"
        DbgText "*****************************************************************************************************"

        mov xax, [xbx].$Obj(NetComConnection).pData
        mov xdi, [xax].SRPS_CONNECTION_DATA.pPeerConnection     ;xdi -> peer connection
        .if xdi != NULL
          mov [xax].SRPS_CONNECTION_DATA.pPeerConnection, NULL
          OCall xdi::NetComConnection.QueueDestroy              ;Destroy peer connection
          OCall xdi::NetComConnection.Close, TRUE
        .endif
        mov eax, PROT_CMD_DESTROY                               ;Destroy self
      .endif

    .else
      DbgWarning "NetComSrpsProtocol.OnError - Unknown operation", "&PROTOCOL_WND_NAME"
      DbgDec [xdx].IO_SOCKJOB.wOperation,, "&PROTOCOL_WND_NAME"
      xor eax, eax
    .endif

  .else
    ;Catch some well known errors
    mov eax, dError
    .if eax == WSAEADDRINUSE
      lea xbx, cBuffer
      mov edi, $32($invoke(htons, [xsi].ListeningAddr.NETCOMADDR.wPort))
      WriteF xbx, "吁T 各D.", $OfsCStr("There is another application listening port"), edi
      OCall xsi.ShowErrorBox, addr cBuffer, dError
    .else
      lea xbx, cBuffer
      WriteF xbx, "Unhandled error"
      OCall xsi.ShowErrorBox, addr cBuffer, dError
    .endif
  .endif
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComSrpsProtocol.ProcessData
; Purpose:    Forwards received data to the paired connection.
; Arguments:  Arg1: -> NetComConnection
;             Arg2: Transmission length
; Return:     Positive INT32 - bytes processed.

Method NetComSrpsProtocol.ProcessData, uses xbx xdi xsi, pConnection:$ObjPtr(NetComConnection), \
                                                         TransmitionLength:DWORD
  local dRemainingBytes:DWORD

;  DbgHex pConnection, "NetComSrpsProtocol.ProcessData", "&PROTOCOL_WND_NAME"
  ?mov xdx, pConnection
  mov xsi, [xdx].$Obj(NetComConnection).pData
  mov xdi, [xsi].SRPS_CONNECTION_DATA.pPeerConnection
  .if xdi == NULL
    xor eax, eax
    ExitMethod
  .endif

  .ifBitSet [xdi].$Obj(NetComConnection).dFlags, NCC_DISCONNECTED_SEND
    DbgHex xdi, "NetComSrpsProtocol.ProcessData =!> Send Disconnected", "&PROTOCOL_WND_NAME"
    xor eax, eax
    ExitMethod
  .endif
  
  lea xbx, [xdx].$Obj(NetComConnection).RcvIOChain      ;xbx -> Sentinel from the incoming connection
  m2m dRemainingBytes, TransmitionLength, eax

  .while TRUE
    ;Get first IOJob from receive chain
    mov xax, [xbx].SDLL_SENTINEL.pFirstItem
    cmp xax, xbx
    .break .if ZERO?                                    ;Chain empty?

    ;Check if the IOJob was completed
    lea xsi, [xax - IO_HEADER_SIZE]                     ;xsi -> IO_SOCKJOB 
    test [xsi].IO_SOCKJOB.wFlags, IOF_JOB_COMPLETED
    .break .if ZERO?                                    ;IOJob receive pending?
    
    ;Remove from receive chain
    mov xdx, [xax].SDLL_ITEM.pNextItem
    mov [xbx].SDLL_SENTINEL.pFirstItem, xdx
    mov [xdx].SDLL_ITEM.pPrevItem, xbx

    OCall xdi::NetComConnection.QueueSend, addr [xsi].IO_SOCKJOB.DataBuffer, [xsi].IO_SOCKJOB.dBytesConsumed
    ;Return value is the number of not queued bytes, what may be different than TransmitionLength
    sub dRemainingBytes, eax
    .if eax != 0
      ;Move the pointer inside IOJob
      mov ecx, [xsi].IO_SOCKJOB.dBytesConsumed
      sub ecx, eax
      add xcx, [xsi].IO_SOCKJOB.WSABuf.buf
      mov [xsi].IO_SOCKJOB.WSABuf.buf, xcx
      mov [xsi].IO_SOCKJOB.dBytesConsumed, eax
      .break
    .endif
    ;Toss the received IOSockJob back in the IOJobPool
    mov xax, [xdi].$Obj(NetComConnection).pOwner
    OCall [xax].$Obj(NetComConnectionPool).pIOSockJobPool::NetComIOSockJobPool.FreeItem, xsi
  .endw

  xor eax, eax                                          ;Dont touch the receive chain
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     NetComSrpsProtocol.Release
; Purpose:    Releases the memory chunk allocated with Allocate.
; Arguments:  Arg1: -> NetComConnection
; Return:     Nothing.

Method NetComSrpsProtocol.Release,, pConnection:$ObjPtr(NetComConnection)
  DbgHex pConnection, "NetComSrpsProtocol.Release", "&PROTOCOL_WND_NAME"
  ?mov xdx, pConnection
  mov xax, [xdx].$Obj(NetComConnection).pData
  MemFree xax
MethodEnd

; --------------------------------------------------------------------------------------------------
; Method:     Application.NetComSrpsProtocol
; Purpose:    Shows a MessageBox displaying a message and WSA error message.
; Arguments:  Arg1: -> Message.
;             Arg2: error code.
; Return:     Nothing.

Method NetComSrpsProtocol.ShowErrorBox, uses xbx xsi, pMessage:PSTRING, dError:DWORD
  local pMsgInfo:PMSG_INFO

  SetObject xsi
  MemAlloc MSG_INFO_SIZE * sizeof(CHR)
  .if xax != NULL
    mov pMsgInfo, xax
    mov [xax].MSG_INFO.dType, MB_OK or MB_ICONERROR
    lea xbx, [xax].MSG_INFO.cBuffer
    mov [xax].MSG_INFO.pMessage, xbx
    invoke StrECopy, xbx, pMessage
    mov xbx, xax
    invoke StrECopy, xbx, offset cCRLF
    invoke StrECopy, xax, offset cCRLF
    invoke StrECopy, xax, $OfsCStr("Description: ")
    mov xbx, xax
    sub xax, pMsgInfo
    neg eax
    add eax, MSG_INFO_SIZE
    if sizeof(CHR) eq 2
      shr eax, 1
    endif
    invoke NetErr2Str, dError, xbx, eax                 ;Returns the number of CHRs written
    if sizeof(CHR) eq 2
      shl eax, 1
    endif
    add xbx, xax
    WriteF xbx, "\nError = 各D", dError
    mov xax, pMsgInfo
    add xbx, sizeof(CHR)
    mov [xax].MSG_INFO.pCaption, xbx
    invoke StrCopy, xbx, offset cError
    mov xax, [xsi].pOwner
    invoke PostMessage, [xax].$Obj(WinApp).hWnd, WM_SHOWMSG, pMsgInfo, NULL
  .endif
MethodEnd

endif

